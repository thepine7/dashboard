# 커서 AI 설정 파일

## 프로젝트 개요
- **프로젝트명**: HnT Sensor API (hnt-sensor-api)
- **기술 스택**: Spring Boot 2.7.1, Java 8, MyBatis, MySQL, MQTT
- **패키징**: WAR 파일 (Tomcat 배포용)
- **기본 포트**: 8888
- **프로젝트 타입**: IoT 센서 데이터 실시간 모니터링 웹 애플리케이션
- **주요 기능**: 실시간 센서 데이터 수집, 사용자 관리, 알림 시스템, 데이터 시각화

## 서버 환경 및 호환성 규칙
- **톰캣 서버**: 9.0-jdk11 버전 사용
- **Java 호환성**: Java 8 코드 (톰캣 9.0-jdk11에서 실행)
- **Spring Boot**: 2.7.1 버전 (톰캣 9.0 완전 호환)
- **패키지 규칙**: javax.* 패키지 사용 (jakarta.* 사용 금지)
- **MyBatis**: 2.3.1 버전 (Spring Boot 2.7.1 호환)
- **JSTL**: javax.servlet.jsp.jstl 사용 (jakarta 사용 금지)
- **HTTP Client**: org.apache.httpcomponents 사용 (client5 사용 금지)
- **Jasper**: Spring Boot에서 자동 제공 (별도 버전 지정 금지)

### 톰캣 9.0-jdk11 호환성 매트릭스
| 구성요소 | 호환 버전 | 비호환 버전 | 상태 |
|---------|----------|------------|------|
| Spring Boot | 2.7.1 | 3.x | ✅ 호환 |
| Java | 8 | 17+ | ✅ 호환 |
| MyBatis | 2.3.1 | 3.x | ✅ 호환 |
| JSTL | javax | jakarta | ✅ 호환 |
| 패키지 | javax.* | jakarta.* | ✅ 호환 |
| HTTP Client | httpcomponents | httpcomponents.client5 | ✅ 호환 |

### 업그레이드 제한사항
- **Spring Boot 3.x 업그레이드 금지**: 톰캣 9.0과 호환되지 않음
- **Java 17+ 업그레이드 금지**: 톰캣 9.0-jdk11 환경에서 실행 불가
- **Jakarta EE 업그레이드 금지**: 톰캣 9.0은 Java EE (javax) 사용
- **MyBatis 3.x 업그레이드 금지**: Spring Boot 2.7.1과 호환되지 않음

## 정적 리소스 경로 규칙 (절대 변경 금지)

### Spring Boot 정적 리소스 서빙 규칙
- **기본 경로**: Spring Boot는 `src/main/resources/static/` 폴더의 파일을 자동으로 서빙
- **URL 매핑**: 
  - `src/main/resources/static/css/` → `/css/`
  - `src/main/resources/static/js/` → `/js/`
  - `src/main/resources/static/images/` → `/images/`
  - `src/main/resources/static/fonts/` → `/fonts/`

### JSP 파일에서 정적 리소스 참조 규칙
- **CSS 파일**: `/css/파일명.css` (절대 `/static/css/` 사용 금지)
- **JavaScript 파일**: `/js/파일명.js` (절대 `/static/js/` 사용 금지)
- **이미지 파일**: `/images/파일명.png` (절대 `/static/images/` 사용 금지)
- **폰트 파일**: `/fonts/파일명.woff` (절대 `/static/fonts/` 사용 금지)

### 정적 리소스 경로 변경 금지 규칙
- **절대 변경 금지**: JSP 파일에서 정적 리소스 경로를 `/static/` 접두사로 변경하지 말 것
- **Spring Boot 기본 동작**: `application.yml`의 `static-path-pattern: "/static/**"` 설정과 무관하게 기본 경로 사용
- **WebConfig 핸들러**: 명시적 핸들러 등록은 보조적 역할, 기본 Spring Boot 동작에 의존
- **호환성 유지**: 기존 작동하는 정적 리소스 경로를 임의로 변경하지 말 것

### 정적 리소스 파일 위치 규칙
- **소스 위치**: `src/main/resources/static/` (절대 변경 금지)
- **배포 위치**: `target/classes/static/` (Maven 빌드 시 자동 생성)
- **서빙 경로**: Spring Boot가 자동으로 `/css/`, `/js/`, `/images/`, `/fonts/`로 서빙

## 프로젝트 폴더 구조
```
src/main/java/com/andrew/hnt/api/
├── controller/          # 컨트롤러 계층
│   ├── MainController.java     (53KB, 1356줄) - 메인 화면 및 센서 데이터 처리
│   ├── AdminController.java    (27KB, 858줄) - 관리자 기능
│   ├── LoginController.java    (9.1KB, 299줄) - 로그인/회원가입
│   ├── DataController.java     (14KB, 445줄) - 데이터 처리
│   ├── ChartController.java    (1.5KB, 48줄) - 차트 관련
│   ├── CommonController.java   (48줄) - 공통 기능
│   ├── DefaultController.java  (26줄) - 기본 컨트롤러
│   └── TestController.java     (2.2KB, 69줄) - 테스트용
│
├── service/            # 서비스 계층
│   ├── impl/           # 서비스 구현체
│   │   ├── AdminServiceImpl.java   (15KB, 542줄)
│   │   ├── LoginServiceImpl.java   (12KB, 390줄)
│   │   ├── MqttServiceImpl.java    (10KB, 262줄)
│   │   └── DataServiceImpl.java    (3.1KB, 112줄)
│   └── *.java          # 서비스 인터페이스
│
├── model/              # 모델/엔티티
│   ├── UserInfo.java       - 사용자 정보
│   ├── SensorVO.java       - 센서 데이터
│   ├── LoginVO.java        - 로그인 정보
│   ├── DataVO.java         - 데이터 전송용
│   └── DeviceVO.java       - 장치 정보
│
├── mapper/              # MyBatis 매퍼 인터페이스
│   ├── AdminMapper.java    (2.2KB, 76줄)
│   ├── LoginMapper.java    (837B, 35줄)
│   ├── DataMapper.java     (513B, 21줄)
│   └── MqttMapper.java     (835B, 30줄)
│
├── config/              # 설정 클래스
│   ├── DbConfig.java       - MyBatis 설정
│   └── WebConfig.java      - 웹 설정
│
├── mqtt/                # MQTT 관련
│   ├── MqttApplicationRunner.java  (6.5KB, 220줄) - MQTT 메시지 수신 처리
│   └── common/
│       └── MQTT.java       (4.8KB, 188줄) - MQTT 클라이언트
│
├── util/                # 유틸리티
│   ├── StringUtil.java     (19KB, 633줄) - 문자열 처리
│   ├── ExcelUtils.java     (13KB, 274줄) - 엑셀 처리
│   └── AES256Util.java     (1.3KB, 35줄) - 암호화
│
└── client/              # 외부 API 클라이언트
    ├── RetroClient.java    (1.5KB, 43줄) - Retrofit 클라이언트
    └── RetroInterface.java (311B, 16줄) - API 인터페이스

src/main/resources/
├── application.yml      # Spring Boot 설정
├── mapper/              # MyBatis XML 매퍼
│   ├── AdminMapper.xml   (13KB, 408줄)
│   ├── LoginMapper.xml   (4.3KB, 126줄)
│   ├── DataMapper.xml    (3.8KB, 88줄)
│   └── MqttMapper.xml    (4.3KB, 124줄)
├── static/              # 정적 리소스
│   ├── css/, js/, images/, fonts/
│   └── jqvmap/          # 지도 관련
└── templates/           # 템플릿 파일

src/main/webapp/WEB-INF/jsp/
├── main/
│   └── main.jsp         (62KB, 1318줄) - 메인 대시보드
├── login/
│   ├── login.jsp        (11KB, 272줄) - 로그인 페이지
│   └── join.jsp         (12KB, 285줄) - 회원가입 페이지
├── admin/
│   ├── sensorSetting.jsp    (110KB, 2565줄) - 센서 설정
│   ├── userList.jsp         (14KB, 229줄) - 사용자 목록
│   ├── userDetail.jsp       (15KB, 237줄) - 사용자 상세
│   ├── createSub.jsp        (11KB, 223줄) - 하위 사용자 생성
│   ├── chartSetting.jsp     (11KB, 234줄) - 차트 설정
│   ├── userModify.jsp       (11KB, 224줄) - 사용자 수정
│   └── sensorSetting_backup*.jsp - 백업 파일들
└── chart/
    └── chart.jsp        - 챠트 데이터 페이지 (제외 대상)
```

## 주요 기능 및 연결고리
- **실시간 센서 모니터링**: MQTT → MySQL 저장
- **사용자 권한 관리**: 계층적 사용자 구조 (Admin/User)
- **알림 시스템**: FCM 푸시 알림, 센서 임계값 기반 알림
- **데이터 시각화**: JFreeChart, 실시간 대시보드, 엑셀 내보내기
- **MQTT 토픽 구조**: HBEE/{sensor_id}/{sensor_type}/{sensor_uuid}/SER

## 코딩 스타일 및 규칙
- 항상 한국어로 응답하세요
- 코드 주석은 한국어로 작성하세요
- 변수명과 함수명은 camelCase를 사용하세요
- 클래스명은 PascalCase를 사용하세요
- 들여쓰기는 2칸 공백을 사용하세요
- 한글은 utf-8로 작성하세요
- 하드코딩은 절대 하지 마세요. 동적으로 처리하세요.
- UI가 같은 페이지의 기능을 변경하거나 추가 할때는 같은 기능을 가진 다른 페이지도 같이 일관성을 유지해야 합니다.

## 프로젝트 특성
- 이 프로젝트는 웹 개발 프로젝트입니다
- Java/Spring Boot를 주로 사용합니다
- 모던하고 깔끔한 코드 스타일을 선호합니다
- mysql 5.7.9 버전을 사용합니다
- 데이터베이스 이름은 hnt 입니다
- 데이터베이스 사용자 이름은 root 입니다
- 데이터베이스 비밀번호는 HntRoot123! 입니다
- 데이터베이스 포트는 3306 입니다
- 데이터베이스 주소는 hntsolution.co.kr 입니다

## AI 동작 지침
- 코드를 작성할 때 항상 타입 안전성을 고려하세요
- 에러 처리를 포함한 견고한 코드를 작성하세요
- 성능과 가독성을 모두 고려하세요
- 새로운 기능 추가 시 기존 코드와의 호환성을 확인하세요
- 새로운 코드 추가 시 기존 코드와 연관된 코드가 있는지 확인하세요

## 🔴 소스 수정 시 필수 준수 룰 (중요!)

### 1. **관련 소스 분석 필수**
- **수정 전 반드시**: 관련된 모든 소스 코드를 분석하고 이해
- **영향도 파악**: 수정할 코드가 다른 기능에 미치는 영향 확인
- **기존 로직 이해**: 원래 코드가 왜 그렇게 작성되었는지 파악
- **성급한 수정 금지**: 분석 없이 임의로 코드 수정 절대 금지

### 2. **기존 작동 방식 보존**
- **원래 동작 유지**: 잘 작동하던 코드의 동작 방식을 임의로 변경 금지
- **Spring Boot 자동 기능 활용**: 프레임워크가 제공하는 자동 기능을 무시하지 말 것
- **세션 관리**: Spring Boot의 자동 세션 관리 방식을 이해하고 활용
- **불필요한 검증 추가 금지**: 기존에 작동하던 로직에 불필요한 검증 로직 추가 금지

### 3. **수정 전 체크리스트**
- [ ] **관련 소스 분석**: 수정할 코드와 연관된 모든 파일 분석
- [ ] **기존 동작 방식 파악**: 원래 코드가 어떻게 작동하는지 이해
- [ ] **영향도 분석**: 수정이 다른 기능에 미치는 영향 확인
- [ ] **Spring Boot 기능 이해**: 프레임워크의 자동 기능 파악
- [ ] **점진적 수정**: 한 번에 여러 곳 수정 금지, 단계별로 수정
- [ ] **테스트 필수**: 수정 후 반드시 테스트 수행

### 4. **잘못된 수정 사례 (경고)**
- ❌ **세션 검증 로직 추가**: Spring Boot가 자동으로 처리하는 세션에 불필요한 검증 추가
- ❌ **직접 링크 변경**: `javascript:goMain()`을 `href="/main/main"`로 임의 변경
- ❌ **기존 함수 로직 변경**: 잘 작동하던 함수의 핵심 로직 임의 수정
- ❌ **분석 없이 수정**: 관련 코드를 제대로 파악하지 않고 성급하게 수정

### 5. **올바른 수정 절차**
1. **문제 파악**: 사용자가 보고한 문제를 정확히 이해
2. **관련 소스 분석**: 문제와 관련된 모든 코드 파일 분석
3. **기존 동작 방식 파악**: 원래 코드가 어떻게 작동하는지 이해
4. **Spring Boot 기능 확인**: 프레임워크가 제공하는 자동 기능 파악
5. **최소한의 수정**: 문제 해결에 필요한 최소한의 코드만 수정
6. **테스트 및 검증**: 수정 후 정상 작동 확인

### 6. **수정 실패 시 대응**
- **즉시 복원**: 잘못된 수정으로 인해 문제가 발생하면 즉시 원래 코드로 복원
- **원인 분석**: 왜 수정이 실패했는지 분석하고 학습
- **재분석**: 더 깊이 있게 관련 소스를 분석
- **점진적 접근**: 작은 수정부터 시작하여 단계적으로 문제 해결

## 컨트롤러별 상세 규칙

### MainController (/main)
- **역할**: 메인 대시보드, 실시간 센서 데이터 처리, 알림 시스템
- **주요 메서드**:
  - `main()`: 메인 화면 렌더링 (GET /main/main)
  - `getData()`: 실시간 센서 데이터 조회 (POST /main/getData)
  - `insertSensorInfo()`: 센서 정보 저장 (POST /main/insertSensorInfo)
  - `sendAlarm()`: 알림 전송 (POST /main/sendAlarm)
- **특징**:
  - CommonController.addSidebarData() 사용하여 사이드바 데이터 처리
  - MQTT 실시간 데이터 수신 및 처리
  - FCM 푸시 알림 기능 포함
- **수정 시 주의사항**:
  - 실시간 데이터 처리 로직 변경 시 MQTT 연결에 영향 주지 않도록 주의
  - 알림 시스템은 기존 로직 유지

### AdminController (/admin)
- **역할**: 관리자 기능, 센서 설정, 사용자 관리
- **주요 메서드**:
  - `sensorSetting()`: 센서 설정 화면 (GET /admin/sensorSetting)
  - `setSensor()`: 센서 설정 변경 (POST /admin/setSensor)
  - `userList()`: 사용자 목록 (GET /admin/userList)
  - `userDetail()`: 사용자 상세 (GET /admin/userDetail)
  - `createSub()`: 하위 사용자 생성 (GET /admin/createSub)
  - `chartSetting()`: 차트 설정 (GET /admin/chartSetting)
- **특징**:
  - MQTT 토픽 생성 및 관리
  - 사용자 권한 관리 (A: 관리자, U: 사용자, B: 일반)
  - 센서 파라미터 설정 기능
- **수정 시 주의사항**:
  - setSensor() 메서드는 MQTT 통신에 직접 영향
  - 사용자 권한 변경 시 세션 관리 주의
  - 센서 설정 변경 시 기존 연결된 센서에 영향 주지 않도록 주의

### LoginController (/login)
- **역할**: 로그인/로그아웃, 회원가입, 사용자 인증
- **주요 메서드**:
  - `login()`: 로그인 페이지 (GET /login/login)
  - `loginProcess()`: 로그인 처리 (POST /login/loginProcess)
  - `logout()`: 로그아웃 (GET /login/logout)
  - `join()`: 회원가입 페이지 (GET /login/join)
  - `joinProcess()`: 회원가입 처리 (POST /login/joinProcess)
- **특징**:
  - 세션 기반 인증
  - 로그인/로그아웃 시간 기록
  - 사용자 등급별 접근 제어
- **수정 시 주의사항**:
  - 세션 관리 로직 변경 시 기존 로그인 사용자에 영향 주지 않도록 주의
  - 비밀번호 암호화 로직 유지
  - 로그인 실패 처리 로직 보존

### DataController (/data)
- **역할**: 데이터 조회, 엑셀 다운로드, 센서 정보 관리
- **주요 메서드**:
  - `getSensorList()`: 센서 목록 조회 (POST /data/getSensorList)
  - `updateSensorInfo()`: 센서 정보 수정 (POST /data/updateSensorInfo)
  - `deleteSensorInfo()`: 센서 정보 삭제 (POST /data/deleteSensorInfo)
  - `excelDownload()`: 엑셀 다운로드 (GET /data/excelDownload)
  - `getDailyData()`: 일간 데이터 조회 (POST /data/getDailyData)
- **특징**:
  - MyBatis를 통한 데이터베이스 조회
  - 엑셀 파일 생성 및 다운로드
  - 센서 데이터 통계 처리
- **수정 시 주의사항**:
  - 데이터베이스 쿼리 성능 고려
  - 대용량 데이터 처리 시 메모리 사용량 주의
  - 엑셀 파일 생성 시 인코딩 처리

### CommonController
- **역할**: 공통 기능 제공
- **주요 메서드**:
  - `addSidebarData()`: 사이드바 데이터 추가
- **특징**:
  - @Component 어노테이션 사용
  - 다른 컨트롤러에서 주입받아 사용
  - 사용자 정보 조회 및 모델에 추가
- **수정 시 주의사항**:
  - 다른 컨트롤러에서 의존하는 공통 기능이므로 변경 시 영향도 고려
  - 예외 처리 로직 보존

### DefaultController
- **역할**: 기본 컨트롤러, 루트 경로 처리
- **주요 메서드**:
  - `root()`: 루트 경로 처리 (GET /)
  - `rootAlt()`: 대체 루트 경로 처리 (GET "")
- **특징**:
  - 모든 컨트롤러의 기본 클래스
  - 루트 접근 시 로그인 페이지로 리다이렉트
- **수정 시 주의사항**:
  - 기본 동작이므로 변경 시 전체 애플리케이션에 영향
  - 로그인 페이지 경로 변경 시 주의

## JSP 페이지별 상세 규칙

### main/main.jsp (메인 대시보드)
- **역할**: 실시간 센서 모니터링, 대시보드 표시
- **주요 기능**:
  - 실시간 온도 표시
  - 센서 상태 모니터링
  - MQTT 실시간 데이터 수신
  - 알림 표시
- **수정 시 주의사항**:
  - MQTT 연결 스크립트 변경 시 실시간 데이터 수신에 영향
  - 실시간 업데이트 로직 보존
  - 반응형 디자인 유지

### login/login.jsp (로그인 페이지)
- **역할**: 사용자 로그인
- **주요 기능**:
  - 사용자 ID/비밀번호 입력
  - 로그인 처리
  - 에러 메시지 표시
- **수정 시 주의사항**:
  - 로그인 폼 구조 변경 시 서버 측 처리 로직 확인
  - 보안 관련 스크립트 유지

### login/join.jsp (회원가입 페이지)
- **역할**: 신규 사용자 등록
- **주요 기능**:
  - 사용자 정보 입력
  - 유효성 검사
  - 회원가입 처리
- **수정 시 주의사항**:
  - 입력 필드 변경 시 서버 측 모델 구조 확인
  - 유효성 검사 로직 동기화

### admin/sensorSetting.jsp (센서 설정)
- **역할**: 센서 파라미터 설정
- **주요 기능**:
  - 센서 파라미터 조회/수정
  - MQTT 통신을 통한 설정 전송
  - 실시간 설정 확인
- **수정 시 주의사항**:
  - MQTT 통신 스크립트 변경 시 센서 제어에 영향
  - 파라미터 설정 로직 보존
  - 실시간 응답 처리 로직 유지

### admin/userList.jsp (사용자 목록)
- **역할**: 사용자 관리
- **주요 기능**:
  - 사용자 목록 표시
  - 사용자 검색/필터링
  - 사용자 정보 수정/삭제
- **수정 시 주의사항**:
  - 사용자 권한별 표시 로직 유지
  - 페이징 처리 로직 보존

### admin/userDetail.jsp (사용자 상세)
- **역할**: 사용자 상세 정보 표시
- **주요 기능**:
  - 사용자 정보 표시
  - 연결된 센서 정보 표시
  - 사용자 정보 수정
- **수정 시 주의사항**:
  - 사용자-센서 연결 관계 표시 로직 유지
  - 권한별 접근 제어 로직 보존

### admin/createSub.jsp (하위 사용자 생성)
- **역할**: 하위 사용자 계정 생성
- **주요 기능**:
  - 하위 사용자 정보 입력
  - 권한 설정
  - 계정 생성 처리
- **수정 시 주의사항**:
  - 사용자 계층 구조 로직 유지
  - 권한 상속 로직 보존

### admin/chartSetting.jsp (차트 설정)
- **역할**: 차트 표시 설정
- **주요 기능**:
  - 차트 표시 옵션 설정
  - 데이터 범위 설정
  - 차트 스타일 설정
- **수정 시 주의사항**:
  - 차트 데이터 연동 로직 유지
  - 설정 저장/로드 로직 보존

## 데이터베이스 관련 규칙

### MyBatis 매퍼 규칙
- **AdminMapper**: 사용자 관리, 센서 정보 관리
- **LoginMapper**: 로그인/회원가입 관련
- **DataMapper**: 센서 데이터 조회, 통계
- **MqttMapper**: MQTT 메시지 처리

### 데이터베이스 쿼리 최적화 규칙 (2025-10-01 추가)
- **기존 인덱스 활용 우선**: 새로운 인덱스 생성 금지, 기존 인덱스 최대한 활용
- **복합 인덱스 우선**: `idx_hnt_sensor_data_uuid_inst_dtm` (uuid, inst_dtm) 활용
- **인덱스 힌트 사용 금지**: USE INDEX, FORCE INDEX 등 사용 금지
- **쿼리 단순화**: 복잡한 중첩 조건문 단순화로 가독성 향상
- **EXPLAIN 확인**: 쿼리 실행 계획으로 인덱스 사용 여부 확인 필수

#### 기존 인덱스 현황
- **hnt_sensor_data**: idx_hnt_sensor_data_uuid_inst_dtm (uuid, inst_dtm)
- **hnt_sensor_data**: idx_hnt_sensor_data_user_id_uuid (user_id, uuid)
- **hnt_sensor_data**: idx_sensor_data_performance (user_id, sensor_id, uuid, inst_dtm)
- **hnt_sensor_info**: idx_sensor_info_user_sensor (user_id, sensor_id)

### 트랜잭션 관리
- **읽기 전용**: `@Transactional(readOnly = true)`
- **쓰기 가능**: `@Transactional`
- **데이터베이스 연결 누수 방지**를 위해 트랜잭션을 적절히 관리

## MQTT 통신 규칙

### 토픽 구조
- **발행용**: HBEE/{sensor_id}/{sensor_type}/{sensor_uuid}/SER
- **구독용**: HBEE/{sensor_id}/{sensor_type}/{sensor_uuid}/DEV

### 메시지 형식
- **실시간 데이터**: `{"actcode": "live", "name": "ain", "value": "27.5"}`
- **설정 응답**: `{"actcode": "setres", "p01": "25.0", ...}`
- **액션 응답**: `{"actcode": "actres", ...}`

### 통신 규칙
- MQTT 연결 상태 모니터링 필수
- 연결 끊김 시 자동 재연결
- 메시지 수신 시 에러 처리

### 실시간 상태표시 유지 규칙 (2025-08-10)
- DIN 이상 유지: `din` value=1 수신 시 이상표시(빨간색)를 유지하고, `din` value=0 수신 전까지 현재온도 수신 등 다른 이벤트가 와도 회색으로 바꾸지 않음
  - 메인: `window['deviceDinErrorStates_'+uuid]` 플래그 사용
  - 센서설정/차트: `window.deviceDinErrorStates` 플래그 사용
- 통신이상 해제 시에도 DIN 이상 플래그가 true면 이상표시를 해제하지 않음
- DIN value=0 수신 시에만 이상표시를 회색으로 해제

### 장치설정 출력 제어/강제제상 UI (2025-08-10)
- 버튼 스타일: `btn-soft`(연한 하이라이트), `btn-on-soft`(ON), `btn-off-soft`(OFF), `is-active`(실행 강조)
- 수동조작(p13)=1일 때만 출력 제어 버튼 동작, 강제제상/종료 버튼은 비활성
- 장치종류가 Heater이면 강제제상/종료 버튼 항상 비활성
- GET&type=2 응답/실시간 output 수신 시 버튼 하이라이트 동기화

### 차트데이터 페이지 날짜 고정 (2025-08-10)
- 선택한 날짜를 `window._currentChartDate`, 데이터 배열을 `window._currentDailyArr`에 저장하고 툴팁/렌더 모두 이 값을 사용
- 포커스 복귀 시 상태/설정 재동기화를 호출하지 않음(날짜 리셋 방지)
- 차트 생성 전 `window.dailyChart`(및 레거시 `window.myChart`) destroy 후 생성하여 hover 시 데이터 변조 방지

## 보안 규칙

### 사용자 인증
- 세션 기반 인증 유지
- 로그인 상태 확인 필수
- 권한별 접근 제어

### 데이터 보안
- SQL Injection 방지
- XSS 공격 방지
- 입력 데이터 검증

## 성능 최적화 규칙

### 데이터베이스
- 인덱스 활용
- 쿼리 최적화
- 연결 풀 관리

### 프론트엔드
- JavaScript 최적화
- 이미지 압축
- 캐싱 활용

## 에러 처리 규칙

### 로깅
- SLF4J + Logback 사용
- 에러 로그 상세 기록
- 디버그 정보 포함

### 사용자 피드백
- 친화적인 에러 메시지
- 에러 상황별 적절한 처리
- 복구 방법 안내

## 테스트 관련
- 새로운 기능 추가 시 테스트 코드도 함께 작성하세요
- JUnit 5와 Spring Boot Test를 사용합니다
- Mockito를 활용한 단위 테스트를 작성하세요
- 통합 테스트는 @SpringBootTest를 사용하세요

## 베스트 프랙티스
- Spring Boot의 자동 설정을 활용하세요
- application.yml 파일을 환경별로 관리하세요
- 트랜잭션 관리는 @Transactional을 사용하세요
- 보안은 Spring Security를 활용하세요

## 빌드 후 배포규칙
- tomcat1은 배포 해줘라고 하면 포트를 수정하고 배포해야합니다.
- 기본적으로 빌드와 배포는 tomcat2만 합니다.
- tomcat1 인지 tomcat2 인지 알려줄것

## 컴파일 후 배포경로
- tomcat1 일때 배포경로는 Y:\docker\tomcat 폴더에 ROOT.war 파일로 배포합니다.
- tomcat2 일때 배포경로는 Y:\docker\tomcat2 폴더에 ROOT.war 파일로 배포합니다.
- tomcat1 일때 포트는 8080 입니다.
- tomcat2 일때 포트는 8888 입니다.
- tomcat1 일때 홈페이지 주소는 iot.hntsolution.co.kr:8080 입니다.
- tomcat2 일때 홈페이지 주소는 iot.hntsolution.co.kr:8888 입니다.
- 포트설정은 tomcat1 일때는 8080, tomcat2 일때는 8888 입니다.
- 포트가 다르기 때문에 빌드는 각각 다른 명령어로 빌드하고 배포해야합니다.
- 빌드후 톰캣1인지 2인지 알려줄것
- 톰캣 서버는 Synology NAS hntsolution.co.kr Synology Container 에서 실행됩니다.

## 톰캣 9.0-jdk11 호환성 배포 규칙
- **서버 환경**: 톰캣 9.0-jdk11 버전 사용
- **Java 호환성**: Java 8 코드로 빌드 (톰캣 9.0-jdk11에서 실행)
- **Spring Boot**: 2.7.1 버전 사용 (톰캣 9.0 완전 호환)
- **패키지 규칙**: javax.* 패키지 사용 (jakarta.* 사용 금지)
- **업그레이드 제한**: Spring Boot 3.x, Java 17+, Jakarta EE 업그레이드 금지
- **의존성 규칙**: 
  - MyBatis 2.3.1 사용 (3.x 사용 금지)
  - javax.servlet.jsp.jstl 사용 (jakarta 사용 금지)
  - org.apache.httpcomponents 사용 (client5 사용 금지)
  - Jasper는 Spring Boot에서 자동 제공 (별도 버전 지정 금지)
- **빌드 명령어**: `mvn clean package -DskipTests`
- **배포 파일**: `hnt-sensor-api-0.0.1-SNAPSHOT.war` → `ROOT.war`
- **배포 후 확인**: 톰캣 서버 재시작 필요

## 앱연동
- 이 프로젝트는 android 앱과 연동되어 있습니다.
- 앱과 연동된 파일은 반드시 존재해야 합니다.
- 앱과 연동된 코드는 절대 삭제하지 마세요.

## 📊 챠트데이터 페이지 상세 분석 (참고용)
### 페이지 접근 구조
- **URL**: `/chart/chart`
- **방식**: GET 요청
- **필수 파라미터**: `userId` (선택적)
- **사이드바 데이터**: `CommonController.addSidebarData()` 호출하여 DB에서 직접 조회

### 일간 데이터 조회 흐름
1. **DataController.chart() 메서드**: 실제 데이터 처리
   - 일간 데이터 조회: `param.put("gu", "d")`
   - `dailyList = dataService.selectSensorData(param)`
   - 데이터 포맷: `inst_dtm + "^" + sensor_value`

2. **DataMapper.xml - selectSensorData 쿼리**:
   ```sql
   -- 일간 데이터 조회 조건
   -- 기간: 현재 시간으로부터 1일 전까지
   -- 그룹화: 시간별, 30분 단위로 그룹화
   -- 집계: 평균값 계산 (round(avg(sensor_value), 1))
   -- 정렬: 날짜 내림차순, 시간 오름차순
   ```

### 프론트엔드 데이터 처리
1. **JSP에서 데이터 수신**: `<input type="hidden" id="daily" value="${daily}" />`
2. **JavaScript에서 데이터 파싱**: 
   - `daily.split(",")` → 배열로 분리
   - `dailyArr[i].split("^")` → 시간과 온도값 분리
3. **Chart.js로 시각화**: 라인 차트 생성

### 데이터베이스 구조
- **hnt_sensor_data 테이블**: 센서 데이터 저장
- **필드**: user_id, sensor_id, uuid, sensor_value, inst_dtm

## 수정 작업 시 필수 체크리스트
1. **영향도 분석**: 수정할 코드가 다른 기능에 미치는 영향 확인
2. **기존 로직 보존**: 핵심 비즈니스 로직 변경 금지
3. **테스트 필수**: 수정 후 반드시 테스트 수행
4. **백업 생성**: 수정 전 현재 상태 백업
5. **단계적 수정**: 한 번에 여러 곳 수정 금지
6. **로깅 추가**: 디버깅을 위한 로그 추가
7. **에러 처리**: 예외 상황 처리 로직 포함
8. **성능 고려**: 수정이 성능에 미치는 영향 확인

## URL 경로 통일 규칙

### 페이지 URL 매핑 규칙 (중복 경로 사용)
- **LoginController**: `/login/login` → `login/login` 뷰
- **MainController**: `/main/main` → `main/main` 뷰
- **ChartController**: `/chart/chart` → `chart/chart` 뷰
- **AdminController**: `/admin/sensorSetting` → `admin/sensorSetting` 뷰
- **AdminController**: `/admin/userList` → `admin/userList` 뷰
- **AdminController**: `/admin/userDetail` → `admin/userDetail` 뷰
- **AdminController**: `/admin/createSub` → `admin/createSub` 뷰
- **AdminController**: `/admin/chartSetting` → `admin/chartSetting` 뷰

### API URL 매핑 규칙 (기존 방식 유지)
- **LoginController**: `/login/loginProcess`, `/login/joinProcess` 등
- **MainController**: `/insertSensorInfo`, `/getData`, `/sendAlarm` 등
- **AdminController**: `/admin/setSensor`, `/admin/saveSensorSetting` 등
- **DataController**: `/data/getSensorList`, `/data/updateSensorInfo` 등

### URL 경로 통일 원칙
- **페이지 URL**: `/{controller}/{view}` 형식 사용 (중복 경로)
- **API URL**: `/{controller}/{method}` 형식 사용 (기존 방식)
- **일관성 유지**: JavaScript에서 페이지 이동 시에도 동일한 경로 사용
- **예외 없음**: 모든 페이지에서 이 규칙을 엄격히 준수

## 세션정보 전달 관련 룰

### 세션 기반 사용자 정보 전달 규칙
- **모든 페이지**: 세션에서 사용자 정보를 직접 조회하여 모델에 설정
- **URL 파라미터 사용 금지**: 사용자 정보를 URL 파라미터로 전달하지 않음
- **일관된 데이터 전달**: 모든 페이지에서 동일한 방식으로 세션 정보 처리

### 세션 정보 처리 순서
1. **세션 유효성 검사**: `isValidSession(session)` 호출
2. **권한 검사**: `hasPermission(session, "B")` 호출  
3. **세션에서 모델로 직접 설정**:
   ```java
   model.addAttribute("userId", session.getAttribute("userId"));
   model.addAttribute("userNm", session.getAttribute("userNm"));
   model.addAttribute("userGrade", session.getAttribute("userGrade"));
   model.addAttribute("sensorId", session.getAttribute("userId"));
   ```
4. **CommonController 호출**: `commonController.addSidebarData(userId, model)`

### 세션 정보 우선순위 규칙
- **세션 값 우선**: 세션에 있는 값이 DB 조회 결과보다 우선
- **CommonController 보완**: 세션에 없는 정보만 DB에서 조회
- **기본값 설정**: 세션 정보가 없을 때만 기본값 사용

### 세션 정보 검증 규칙
- **필수 세션 정보**: `userId`, `userNm`, `userGrade`
- **선택적 세션 정보**: `userEmail`, `userTel`, `loginUserId`
- **세션 누락 시**: 로그인 페이지로 리다이렉트

### 페이지별 세션 정보 전달 방식
- **MainController**: 세션 → 모델 → JSP
- **ChartController**: 세션 → 모델 → JSP  
- **AdminController**: 세션 → 모델 → JSP
- **LoginController**: 로그인 성공 시 세션 설정

### 세션 정보 보안 규칙
- **세션 타임아웃**: 30분 (application.yml 설정)
- **세션 무효화**: 로그아웃 시 세션 완전 삭제
- **권한별 접근 제어**: 사용자 등급에 따른 페이지 접근 제한

### 세션 정보 디버깅 규칙
- **개발 환경**: 세션 정보 로깅 활성화
- **운영 환경**: 세션 정보 로깅 최소화
- **에러 상황**: 세션 정보 누락 시 상세 로그 기록 

## 로그인 상태 관리 규칙 (2025-10-19 추가)

### DB 컬럼 의미 명확화
- **`last_login_dtm`**: 로그인 상태 플래그 (CHAR(1))
  - `'Y'`: 로그인 중 (PC 또는 앱)
  - `'N'`: 로그아웃
  - **주의**: 컬럼명은 `dtm`이지만 실제로는 datetime이 아닌 상태 플래그
- **`logout_dtm`**: 로그아웃 상태 플래그 (CHAR(1))
  - `'Y'`: 로그아웃
  - `'N'`: 로그인 중
  - **주의**: 컬럼명은 `dtm`이지만 실제로는 datetime이 아닌 상태 플래그
- **`mdf_dtm`**: 마지막 활동 시간 (DATETIME)
  - 로그인 시: 현재 시간으로 설정
  - 하트비트: 2분마다 현재 시간으로 갱신
  - 타임아웃 체크: 이 값을 기준으로 비활성 사용자 판단

### 활성/비활성 판단 로직
```sql
-- 사용자 목록 조회 시 활성/비활성 판단
case 
    when u.user_id = #{currentUserId} then '활성'  -- 현재 로그인한 사용자
    when u.last_login_dtm = 'Y' and u.logout_dtm = 'N' then '활성'  -- 다른 활성 사용자
    else '비활성'  -- 로그아웃 또는 타임아웃
end as loginYn
```

### 로그인 처리 (PC/앱 공통)
```java
// LoginController.loginProcess()
session.setAttribute("userId", userId);
session.setAttribute("userNm", userNm);
session.setAttribute("userGrade", userGrade);

// DB 상태 업데이트
loginService.updateLoginDtm(loginVO);
// → last_login_dtm='Y', logout_dtm='N', mdf_dtm=NOW()
```

### 로그아웃 처리 (PC/앱 공통)
```java
// LoginController.logout() 또는 logoutProcess()
session.invalidate();

// DB 상태 업데이트
loginService.updateLogoutDtm(loginVO);
// → last_login_dtm='N', logout_dtm='Y'
```

### 하트비트 메커니즘 (브라우저/앱 강제 종료 대응)
- **프론트엔드**: `/js/heartbeat-manager.js`
  - 2분마다 `/api/heartbeat` 엔드포인트에 AJAX 전송
  - 페이지 로드 시 자동 시작
  - 페이지 숨김 시에도 하트비트 유지 (백그라운드 탭도 활성으로 간주)
- **백엔드**: `LoginController.heartbeat()`
  - 세션에서 userId 추출
  - `loginService.updateUserActivity(userId)` 호출
  - DB의 `mdf_dtm` 컬럼을 현재 시간으로 갱신
- **효과**: 브라우저/앱이 정상 동작 중이면 2분마다 활동 신호 전송

### 자동 타임아웃 처리 (스케줄러 기반)
- **스케줄러**: `UserActivityScheduler.java`
  - 3분마다 실행 (`@Scheduled(fixedDelay = 180000)`)
  - `loginService.checkAndUpdateSessionTimeout()` 호출
- **타임아웃 임계값**: 3분 (180초)
  - 하트비트 2분 + 여유 1분 = 3분
  - `mdf_dtm`으로부터 3분 이상 지난 사용자를 비활성 처리
- **DB 업데이트**:
  ```sql
  UPDATE hnt_user 
  SET last_login_dtm = 'N', logout_dtm = 'Y', mdf_dtm = NOW()
  WHERE del_yn = 'N'
    AND last_login_dtm = 'Y'
    AND logout_dtm = 'N'
    AND TIMESTAMPDIFF(SECOND, mdf_dtm, NOW()) > 180
  ```
- **효과**: 브라우저/앱 강제 종료 후 3분 이내 "비활성" 표시

### 세션 타임아웃 처리
- **세션 타임아웃**: 30분 (`application.yml` 설정)
- **SessionListener**: 세션 만료 시 자동 로그아웃
  - `SessionListener.sessionDestroyed()` 호출
  - `loginService.updateLogoutDtm()` 호출
  - DB 상태: `last_login_dtm='N'`, `logout_dtm='Y'`
- **주의**: 세션 타임아웃은 30분이지만, 하트비트 메커니즘으로 3분 이내 비활성 처리

### 사용자 목록 조회 최적화
- **N+1 쿼리 문제 해결**: `getUserListWithActivityStatus()` 사용
- **SQL에서 활성/비활성 계산**: 별도의 Java 로직 불필요
- **레거시 메서드**: `getUserList()`, `getUserAndSubUserList()`는 호환성 유지
  - 중복 로직 제거됨 (주석 처리)
  - 최적화된 쿼리 사용 권장

### 사용자 정보 수정 단순화
- **userModify.jsp**: 복잡한 동기화 로직 제거
  - 전역 변수 `formData` 제거
  - `input`/`blur` 이벤트 리스너 제거
  - DOM에서 직접 값 읽기 (단일 소스)
  - 디버그 로그 최소화
- **코드 감소**: 180줄 → 60줄 (67% 감소)

### 페이지별 실시간 상태 갱신
- **userList.jsp**: 5초마다 사용자 목록 갱신
  - `getChangeList()` 함수 호출
  - 활성/비활성 상태 실시간 업데이트
  - 색상: 활성(파란색), 비활성(회색)

### 디버깅 및 로깅
- **하트비트 로그**: `console.log('하트비트 전송 성공')`
- **스케줄러 로그**: `logger.info("=== 비활성 사용자 체크 시작 ===")`
- **타임아웃 로그**: 타임아웃 대상 사용자 목록 로깅
- **개발 환경**: 상세 로그 활성화
- **운영 환경**: 필수 로그만 기록

### 테스트 시나리오
1. **정상 로그인**: 활성 상태 확인
2. **정상 로그아웃**: 비활성 상태 확인
3. **브라우저 강제 종료**: 3분 후 비활성 확인
4. **앱 강제 종료**: 3분 후 비활성 확인
5. **하트비트 전송**: 2분마다 `mdf_dtm` 갱신 확인
6. **스케줄러 실행**: 3분마다 비활성 사용자 처리 확인
7. **세션 타임아웃**: 30분 후 자동 로그아웃 확인

# 커서 AI 설정 파일

## 프로젝트 개요
- **프로젝트명**: HnT Sensor API (hnt-sensor-api)
- **기술 스택**: Spring Boot 2.7.1, Java 8, MyBatis, MySQL, MQTT
- **패키징**: WAR 파일 (Tomcat 배포용)
- **기본 포트**: 8888
- **프로젝트 타입**: IoT 센서 데이터 실시간 모니터링 웹 애플리케이션
- **주요 기능**: 실시간 센서 데이터 수집, 사용자 관리, 알림 시스템, 데이터 시각화

## 서버 환경 및 호환성 규칙
- **톰캣 서버**: 9.0-jdk11 버전 사용
- **Java 호환성**: Java 8 코드 (톰캣 9.0-jdk11에서 실행)
- **Spring Boot**: 2.7.1 버전 (톰캣 9.0 완전 호환)
- **패키지 규칙**: javax.* 패키지 사용 (jakarta.* 사용 금지)
- **MyBatis**: 2.3.1 버전 (Spring Boot 2.7.1 호환)
- **JSTL**: javax.servlet.jsp.jstl 사용 (jakarta 사용 금지)
- **HTTP Client**: org.apache.httpcomponents 사용 (client5 사용 금지)
- **Jasper**: Spring Boot에서 자동 제공 (별도 버전 지정 금지)

### 톰캣 9.0-jdk11 호환성 매트릭스
| 구성요소 | 호환 버전 | 비호환 버전 | 상태 |
|---------|----------|------------|------|
| Spring Boot | 2.7.1 | 3.x | ✅ 호환 |
| Java | 8 | 17+ | ✅ 호환 |
| MyBatis | 2.3.1 | 3.x | ✅ 호환 |
| JSTL | javax | jakarta | ✅ 호환 |
| 패키지 | javax.* | jakarta.* | ✅ 호환 |
| HTTP Client | httpcomponents | httpcomponents.client5 | ✅ 호환 |

### 업그레이드 제한사항
- **Spring Boot 3.x 업그레이드 금지**: 톰캣 9.0과 호환되지 않음
- **Java 17+ 업그레이드 금지**: 톰캣 9.0-jdk11 환경에서 실행 불가
- **Jakarta EE 업그레이드 금지**: 톰캣 9.0은 Java EE (javax) 사용
- **MyBatis 3.x 업그레이드 금지**: Spring Boot 2.7.1과 호환되지 않음

## MQTT 통신 프로토콜 규칙

### 기본 토픽 구조
- **공통 토픽 형식**: `HBEE/($userId)/TC/($mac)/DEV`
- **서버 요청 토픽**: `HBEE/($userId)/TC/($mac)/SER`
- **클라이언트 구독 토픽**: `HBEE/+/+/+/DEV` (응답 수신용)
- **메시지 필터링**: 마지막 요소가 DEV인 경우만 처리 (응답 메시지)

### 장치 UUID 규칙 (2025-10-06 추가)
- **UUID 형식**: WiFi MAC 주소를 장치(센서)의 UUID로 사용
- **MAC 주소 형식**: 12자리 16진수 (콜론/하이픈 없음) - 예: `0008DC7553A4`
- **UUID 검증 패턴**:
  - **표준 UUID**: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx` (하이픈 포함, 36자)
  - **MAC 주소 UUID**: `xxxxxxxxxxxx` (하이픈 없음, 12자리 16진수)
- **검증 정규식**:
  ```javascript
  // 표준 UUID 패턴
  var standardUuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  // MAC 주소 패턴
  var macAddressPattern = /^[0-9a-f]{12}$/i;
  ```
- **사용 위치**: 
  - MQTT 토픽의 `($mac)` 세그먼트
  - 센서 데이터의 `sensor_uuid` 필드
  - 프론트엔드 JavaScript의 UUID 검증 로직

### 메시지 타입별 규칙

#### 1. 현재 온도 알림 (Current Temperature Notification)
- **목적**: 현재 온도(또는 기타 센서) 측정값 전송
- **JSON 페이로드**:
```json
{
  "actcode": "live",
  "name": "ain",
  "type": "1"~"99",
  "ch": "1" ~ "99",
  "value": "23.5"
}
```
- **설명**:
  - `actcode`: "live" (실시간 데이터)
  - `name`: "ain" (Analog Input)
  - `type`: "1"~"99" (temp, humidity, Pressure, CO2, PT100, 4-20mA 등)
  - `ch`: "1"~"99" (채널 번호)
  - `value`: 센서 측정값 (예: "23.5")
  - **에러 처리**: 센서 연결 에러 시 `value`는 `"Error"`로 전송

#### 2. Input 상태 변화 알림 (Input Status Change Notification)
- **목적**: Input 상태 변화 알림
- **JSON 페이로드**:
```json
{
  "actcode": "live",
  "name": "din",
  "type": "1" ~ "99",
  "ch": "1" ~ "99",
  "value": "0" ~ "65000"
}
```
- **설명**:
  - `actcode`: "live"
  - `name`: "din" (Digital Input)
  - `type`: "1"~"99" (Alarm, H/L, Counter, Freq 등)
  - `ch`: "1"~"99" (채널 번호)
  - `value`: "0"~"65000" (수치값)

#### 3. Output 상태 변화 알림/출력 단자 수동 제어 응답
- **목적**: Output 상태 변화 알림 또는 출력 단자 수동 제어에 대한 응답
- **JSON 페이로드**:
```json
{
  "actcode": "live",
  "name": "output",
  "type": "1" ~ "99",
  "ch": "1" ~ "99",
  "value": "1" or "0"
}
```
- **설명**:
  - `actcode`: "live"
  - `name`: "output"
  - `type`: "1"~"99" (COMP, DEF, FAN, DOUT, ROUT, AOUT 등)
  - `ch`: "1"~"99" (채널 번호)
  - `value`: "1" or "0" (ON/OFF 상태)
- **전송 로직**: 브로커 초기 연결 시 1회 전송, 이후 이벤트 발생 시마다 전송

### 서버 요청 및 장치 응답 규칙

#### 파라미터 읽기 (GET&type=1)
- **요청**: `GET&type=1` → type 1: parameter, 2: status
- **응답 actcode**: `setres`
- **응답 JSON**:
```json
{
  "actcode": "setres",
  "p01": "1" ~ "99",
  "p02": "1" ~ "99",
  "p03": "1" ~ "99",
  "p04": "1" ~ "99",
  "p05": "1" ~ "99",
  ...
  "pxx": "1" ~ "99"
}
```
- **설명**: 장치의 설정 파라미터(p01~p16)를 읽어오는 응답

#### 상태 읽기 (GET&type=2)
- **요청**: `GET&type=2` → type 1: parameter, 2: status
- **응답 actcode**: `live`
- **응답 JSON (Input 상태)**:
```json
{
  "actcode": "live",
  "name": "din",
  "type": "1" ~ "99",
  "ch": "1" ~ "99",
  "value": "0" ~ "65000"
}
```
- **응답 JSON (Output 상태)**:
```json
{
  "actcode": "live",
  "name": "output",
  "type": "1" ~ "99",
  "ch": "1" ~ "99",
  "value": "1" or "0"
}
```
- **설명**: 
  - Input 상태: `name: "din"` (Digital Input) - Alarm, H/L, Counter, Freq 등
  - Output 상태: `name: "output"` - COMP, DEF, FAN, DOUT, ROUT, AOUT 등

#### 파라미터 설정
- **요청**: `SET&p01=100&p02=10&p03=0&p04=0&p05=4&p06=20&p07=0&p08=60&p09=60&p10=0&p11=1&p12=0&p13=1&p14=3&p15=0&p16=0`

#### 강제 제상 시작/종료
- **시작 요청**: `ACT&name=forcedef&value=1`
- **종료 요청**: `ACT&name=forcedef&value=0`
- **응답 actcode**: `actres`
- **응답 JSON**:
```json
{
  "actcode": "actres",
  "name": "forcedef"
}
```

#### 출력 단자 수동 제어
- **요청**: `ACT&name=output&type=1&ch=1&value=0`
- **Type 종류**: COMP, DEF, FAN, DOUT, ROUT, AOUT, 99
- **응답 actcode**: `actres`
- **응답 JSON**:
```json
{
  "actcode": "actres",
  "name": "output"
}
```

#### 등록 초기화(장치 삭제)
- **요청**: `ACT&name=userId&value=0`
- **응답 actcode**: `actres`
- **응답 JSON**:
```json
{
  "actcode": "actres",
  "name": "userId"
}
```

### 파라미터 설정 규칙 (p01~p16)

| 파라미터 | 기본값 | 디코딩 | 설명 | 범위 | 인코딩 |
|---------|--------|--------|------|------|--------|
| p01 | 100 | 10.0 | 설정 온도 | -50.0 ~ 125 / -200 ~ 850 | -500 ~ 1250 / -2000 ~ 8500 |
| p02 | 10 | 1.0 | 히스테리시스 편차 | 0.1 ~ 19.9 | 1 ~ 199 |
| p03 | 0 | 0 | COMP 출력 지연시간(sec) | 0 ~ 599 | 0 ~ 599 |
| p04 | 0 | 0.0 | 온도 보정 | -10.0 ~ 10.0 | -100 ~ 100 |
| p05 | 4 | 4 | 제상 정지시간(hour) | 0 ~ 250 | 0 ~ 250 |
| p06 | 20 | 20 | 제상 시간(min) | 0 ~ 250 | 0 ~ 250 |
| p07 | 0 | F1 | 팬 설정 | F1 ~ F4 | 0 ~ 3 |
| p08 | 60 | 60 | 제상 후 FAN ON 지연시간(sec) | 0 ~ 599 | 0 ~ 599 |
| p09 | 60 | 60 | FAN OFF 지연시간(sec) | 0 ~ 599 | 0 ~ 599 |
| p10 | 0 | 0.0 | 저온 방지 온도편차 | 0.0 ~ 9.9 | 0 ~ 99 |
| p11 | 1 | ON | COMP 누적 시간 제상 선택 | ON/OFF | 1/0 |
| p12 | 0 | T-1 | 온도 센서 타입 | T1~T3 | 0~2 |
| p13 | 1 | ON | 수동조작 on/off | ON/OFF | 1/0 |
| p14 | 3 | 1 | 통신 국번 | 01~99 | 1~99 |
| p15 | 0 | 9600 | 통신 속도 | 1200~19200 | 0~4 |
| p16 | 0 | Cooler | Cooler/Heater 모드 선택 | Heater/Cooler | 1/0 |

**참고사항**:
- T1, T2 센서 타입: 범위 -50.0 ~ 125, 인코딩 -500 ~ 1250
- T3 센서 타입: 범위 -200 ~ 850, 인코딩 -2000 ~ 8500
- -200.0은 2000으로, -20.0은 200으로 인코딩 (실제값 × 10)

## 실시간 모니터링 규칙 (2025-08-03 정밀 분석 기반)

### 데이터 수신 주기
- **현재온도**: 5초마다 수신됨 (live 메시지의 ain 데이터)
- **상태 데이터**: 상태 변화 시 즉시 수신 (din, output 메시지)

### 초기 페이지 로딩 시 요청
- **실행 조건(게이트)**: 페이지 로딩 완료(`window.load`) + MQTT 연결 성공(`mqtt:connected` 이벤트) 둘 다 충족 시 1회 수행
- **요청 타이밍**:
  1. GET&type=1 (설정값 요청) - 조건 충족 후 0.5초
  2. GET&type=2 (상태표시 요청) - 위 요청 후 2.0초(+2.0s)
- **응답 처리**: 각각의 요청값에 맞는 데이터를 파싱하고 UI에 표시

### 상태 변경 시 처리
- **초기설정**: 운전 녹색, 나머지 회색
- **초기 로딩 이후**: 상태가 변경될 때 장치에서 상태표시값을 자동으로 전송
- **상태표시값 수신**: 실시간으로 상태표시값을 받으면 UI 갱신
- **추가 요청 불필요**: 초기 로딩 후에는 별도의 GET&type=1, GET&type=2 요청을 하지 않음

### 실시간 온도 데이터 기반 에러 처리 규칙
- **에러 추적 변수**: `deviceLastDataTime`, `deviceErrorCounters`, `deviceErrorStates`
- **에러 카운터**: 3번 연속 미수신 시 에러 상태로 변경
- **에러 조건**: 15초 동안 온도 데이터 미수신
- **에러 상태 지속**: 에러 상태가 되면 더 이상 에러체크를 하지 않음
- **에러 해제**: 정상 온도 데이터 수신 시 자동으로 에러 해제 및 상태 복구
- **에러 해제후**: GET&type=1을 2초 후 1회, 이어서 2초 뒤 GET&type=2 1회 요청(총 2초 간격)
- **에러 복구**: 에러 해제 후 15초 동안 온도 데이터 미수신 시 에러 상태로 변경
- **메인 페이지**: 장치별로 독립적으로 동작하며 장치별 에러 체크 함수 호출
- **센서설정 페이지**: 해당센서에만 국한되어 에러체크 함수 호출


### 장치별 독립적인 상태 관리 규칙
- **장치별 상태 추적 변수**: 각 장치마다 독립적인 상태 변수 관리
  - `deviceStatusStates`: 장치별 운전 상태 ('gray', 'green')
  - `deviceErrorDisplayStates`: 장치별 이상 표시등 상태 ('gray', 'red')
  - `deviceTempStates`: 장치별 온도 표시 상태
  - `deviceDinErrorStates`: 장치별 DIN 이상 상태
- **장치별 완전 독립**: 한 장치의 상태 변경이 다른 장치에 영향 없음
- **장치별 에러 처리**: 각 장치마다 독립적인 에러 카운터 및 상태 관리
- **장치별 DOM 요소**: `$('#status'+sensor_uuid)` 형태로 장치별 고유 ID 사용
- **장치별 로깅**: 각 장치의 상태 변경을 독립적으로 로그 기록

### 상태표시등 색상 규칙

#### 기본 상태표시등
- **운전/콤프/제상/FAN**: 회색 (기본 상태)
- **콤프/제상/FAN 동작**: 빨간색 (활성 상태)
- **이상**: 
  - 이상일 때 빨간색
  - 기본 상태는 회색
- **운전**: 
  - 정상일 때 녹색
  - 통신이상이면 회색

#### DIN 처리 시 규칙
- **DIN value=1**: 운전 녹색, 이상 빨간색
- **DIN value=0**: 운전 녹색, 이상 회색

#### 실시간 온도 처리 시 규칙
- **실시간 온도가 Error일때**:
  - 이상: 빨간색
  - 운전: 녹색 (정상 상태 유지)
  - 현재온도: "Error" 표시
- **Error에서 정상 복구 시**:
  - 이상: DIN 이상 상태가 없으면 회색으로 변경
  - 운전: 녹색으로 변경
  - 현재온도: 정상 온도값으로 표시

#### 통신이상 시 표시
- **현재온도**: "Error" 표시
- **이상 상태표시등**: 빨간색 (통신이상)
- **운전/콤프/제상/FAN 상태표시등**: 회색 (비활성)

### 상태표시등 깜빡임 방지 규칙
- **중복 방지 로직**: 실제 DOM 요소의 이미지 src 속성을 직접 비교하여 중복 업데이트 방지
- **이미지 src 직접 비교**: `$('#status'+sensor_uuid+' img').attr('src') !== '/images/green.png'`
- **변수 기반 비교 대신**: DOM 상태와 변수 상태의 동기화 보장
- **적용 대상**: 모든 상태표시등 (운전, 콤프, 제상, FAN, 이상)
- **성능 최적화**: 불필요한 DOM 조작 최소화로 깜빡임 현상 완전 제거
- **안정성 향상**: 실제 화면 상태와 내부 변수 상태의 일치성 보장

### 사용자별 장치 필터링 규칙
- **현재 사용자 확인**: 토픽에서 추출한 userId와 현재 로그인한 사용자 비교
- **필터링 조건**: 현재 사용자의 장치가 아닌 경우 파싱하지 않음
- **처리 순서**: 
  1. 토픽에서 userId 추출
  2. 현재 로그인한 사용자와 비교
  3. 일치하지 않으면 즉시 return (파싱 중단)
  4. 일치하는 경우에만 메시지 파싱 및 처리 진행
- **UI 장치리스트 필터링**: 추가로 UI에 표시되는 장치리스트에 있는 장치만 처리

### 설정값 표시 방법
- **설정온도**: GET&type=1 응답의 p01 파라미터에서 추출하여 표시 (디코딩 규칙 적용)
- **상태표시등**: GET&type=2 응답의 din/output 메시지에서 실시간 상태 업데이트 (색상 규칙 적용)
- **현재온도**: live 메시지의 ain 데이터에서 실시간 업데이트 (5초마다, 에러 시 "Error" 표시)
- **표시 우선순위**: 현재온도 > 설정온도 > 상태표시등 순으로 업데이트

### 메시지 파싱 및 처리 규칙
- **배열 형태 메시지 처리**: MQTT 메시지가 배열 형태로 수신되는 경우 첫 번째 요소 추출 후 처리
- **JSON 유효성 검사**: 메시지 파싱 전 JSON 유효성 검사 수행
- **토픽 구조별 파싱**: 
  - 5개 이상 요소: `HBEE/userId/TC/uuid/DEV` → uuid=topicArr[3], userId=topicArr[1]
  - 4개 요소: `HBEE/userId/uuid/DEV` → uuid=topicArr[2], userId=topicArr[1]
  - 4개 미만: 파싱 불가 (undefined 처리)
- **초기 로딩 시 에러 표시 방지**: 페이지 초기 로딩 시 데이터가 없는 경우 "Error" 표시하지 않고 빈 상태로 유지

### 페이지 간 이동 및 세션 관리 규칙
- **Main 링크 처리**: 장치설정페이지에서 Main 클릭 시 다중 소스에서 사용자 정보 확인
- **세션 정보 확인 순서**:
  1. Hidden input 필드 (`userId`, `loginUserId`, `userGrade`)
  2. URL 파라미터 (`?userId=xxx&userGrade=xxx`)
  3. 세션 정보
- **세션 만료 처리**: 사용자 정보가 없을 때 명확한 에러 메시지와 함께 로그인 페이지로 이동
- **기본값 설정**: userGrade가 없을 때 기본값 "U" 설정

### 백업 폴더
- **백업 폴더**: D:\Project\SW\CursorAI\backup 폴더에 오늘 날짜로 백업
- 백업업 할때 README.md 도 같이 백업

## 🔄 내일 작업 예정 (2025-08-03)

### 우선순위 1: 에러 체크 문제 해결
- **문제**: 장치별 에러 체크가 독립적으로 동작하지 않음
- **현상**: 한 장치 에러 시 모든 장치 상태가 변경됨
- **해결 방안**: 
  - `chkError_${item.sensor_uuid}` 함수 호출 방식 수정
  - 장치별 독립적인 에러 상태 관리 로직 구현
  - 에러 체크 함수의 DOM 요소 선택자 수정

### 우선순위 2: 실제 기능 테스트
- **사용자 삭제 기능**: 부계정 vs 메인 사용자 구분 삭제 테스트
- **장치 삭제 기능**: 센서 데이터 완전 삭제 테스트
- **부계정 권한 제한**: 장치 삭제/수정 버튼 숨김 테스트
- **장치 전송 기능**: 기존 소유자 데이터 삭제 후 새 소유자 등록 테스트

### 우선순위 3: 성능 최적화
- **DB 인덱스**: 성능 개선 효과 확인
- **MQTT 연결**: 안정성 개선 효과 확인
- **콘솔 로그**: 디버그 메시지 필터링 효과 확인

## 사용자 관리 및 권한 규칙

### 사용자 등급별 권한 체계
- **A (관리자)**: 모든 기능 사용 가능
- **U (일반사용자)**: 장치 삭제/수정 가능
- **B (부계정)**: 장치 삭제/수정 불가능 (읽기 전용)

### 부계정 삭제 시 데이터 처리 규칙
- **부계정 삭제 시**: 부계정 사용자 정보만 삭제하고 메인 사용자의 장치 정보는 보존
- **메인 사용자 삭제 시**: 모든 사용자 관련 데이터 완전 삭제

#### 삭제 로직 비교
| 사용자 등급 | 삭제되는 데이터 | 보존되는 데이터 |
|------------|----------------|----------------|
| **B (부계정)** | `hnt_user` 테이블의 부계정 정보만 | 메인 사용자의 모든 장치 정보 및 센서 데이터 |
| **A/U (메인)** | 모든 사용자 관련 데이터 | 없음 (완전 삭제) |

#### 부계정 삭제 시 보존되는 데이터
- **장치 기본 정보**: `hnt_sensor_info` 테이블의 메인 사용자 장치 정보
- **장치 설정 정보**: `hnt_config` 테이블의 메인 사용자 설정 정보
- **센서 데이터**: `hnt_sensor_data` 테이블의 메인 사용자 센서 데이터
- **알림 데이터**: `hnt_alarm` 테이블의 메인 사용자 알림 데이터

#### 메인 사용자 삭제 시 삭제되는 데이터
- **사용자 정보**: `hnt_user` 테이블의 사용자 정보
- **장치 기본 정보**: `hnt_sensor_info` 테이블의 모든 장치 정보
- **장치 설정 정보**: `hnt_config` 테이블의 모든 설정 정보
- **센서 데이터**: `hnt_sensor_data` 테이블의 모든 센서 데이터
- **알림 데이터**: `hnt_alarm` 테이블의 모든 알림 데이터

### 부계정 권한 제한 기능
- **백엔드 권한 체크**: 부계정(B 등급) 사용자의 장치 삭제/수정 시도 차단
- **프론트엔드 권한 체크**: 부계정 사용자에게 관리 메뉴 및 삭제/수정 버튼 숨김
- **이중 보안**: 프론트엔드 + 백엔드 모두에서 권한 체크
- **로그 기록**: 권한 없는 사용자의 시도 로그 기록
- **명확한 에러 메시지**: 사용자에게 권한 부족 이유 안내

## 부계정 관계 관리 규칙

### 부계정 판단 로직 (2025-09-24 수정)
- **기존 문제**: `login_user_id` 컬럼이 존재하지 않아 부계정 판단 실패
- **수정된 로직**: `hnt_sensor_info` 테이블의 `sensor_id` 컬럼으로 부계정 관계 관리
- **판단 기준**: 
  - `user_id = sensor_id`: 주계정 (센서 소유자)
  - `user_id ≠ sensor_id`: 부계정 (센서 공유 사용자)

### 부계정 관계 확인 방법
```sql
-- 부계정 여부 확인
SELECT CASE 
    WHEN EXISTS (
        SELECT 1 FROM hnt_sensor_info s 
        WHERE s.user_id = '사용자ID' AND s.sensor_id = '사용자ID'
    ) THEN '주계정'
    WHEN EXISTS (
        SELECT 1 FROM hnt_sensor_info s 
        WHERE s.user_id = '사용자ID' AND s.sensor_id != '사용자ID'
    ) THEN '부계정'
    ELSE '센서없음'
END as '계정유형';

-- 부계정의 메인 사용자 ID 조회
SELECT DISTINCT s.sensor_id 
FROM hnt_sensor_info s 
WHERE s.user_id = '부계정ID' 
LIMIT 1;
```

### MainController 부계정 처리 로직
```java
// 부계정 여부 확인 (hnt_sensor_info 테이블 기반)
boolean isSubAccount = adminService.isSubAccount(sessionUserId);

if(isSubAccount) {
    // 부계정인 경우: 메인 계정의 센서 리스트 조회
    String mainUserId = adminService.getMainUserIdForSubUser(sessionUserId);
    sensorList = adminService.getSubSensorList(mainUserId, sessionUserId);
} else {
    // 메인 계정인 경우: 일반 센서 리스트 조회
    sensorList = adminService.getSensorList(sessionUserId);
}
```

### AdminService 부계정 관련 메서드
- **`isSubAccount(String userId)`**: 부계정 여부 확인
- **`getMainUserIdForSubUser(String subUserId)`**: 부계정의 메인 사용자 ID 조회
- **`getSubSensorList(String mainUserId, String subUserId)`**: 부계정이 접근 가능한 센서 리스트 조회

### 부계정 센서 접근 권한
- **센서 소유권**: `hnt_sensor_info.user_id` = 센서를 사용하는 사용자
- **센서 소유자**: `hnt_sensor_info.sensor_id` = 센서의 실제 소유자
- **부계정 접근**: `user_id ≠ sensor_id`인 경우 부계정이 주계정의 센서 공유 사용

## 부계정 권한 및 MQTT 토픽 구독 규칙 (2025-10-18 추가)

### 부계정 판단 조건 (최종 확정)
```javascript
// 프론트엔드 (JSP)
var userId = '${userId}';
var parentUserId = '${parentUserId}';
var isSubAccount = (parentUserId && parentUserId !== '' && parentUserId !== 'null' && parentUserId !== userId);
```

```java
// 백엔드 (Java)
String userId = (String) session.getAttribute("userId");
String parentUserId = (String) session.getAttribute("parentUserId");
boolean isSubAccount = (parentUserId != null && !parentUserId.isEmpty() && !parentUserId.equals(userId));
```

**판단 기준**:
- `parentUserId`가 **null이면**: 주계정 (모든 기능 사용 가능)
- `parentUserId`가 **null이 아니고** `userId`와 **다르면**: 부계정 (읽기 전용)
- `parentUserId`가 **null이 아니고** `userId`와 **같으면**: 주계정 (모든 기능 사용 가능)

### 부계정 권한 정책 (최종 확정)

| 기능 | 주계정 | 부계정 | 비고 |
|------|--------|--------|------|
| **모든 페이지에서 설정값/상태값 조회** (GET&type=1, GET&type=2) | ✅ 가능 | ✅ **가능** | UI 갱신을 위해 필요 |
| **MQTT 토픽 구독** | ✅ 가능 | ✅ **가능** | 센서 소유자 ID로 구독 |
| **센서 설정 변경** (AdminController.setSensor - param) | ✅ 가능 | ❌ **불가** | 백엔드 차단 (403) |
| **강제제상 시작/종료** (defrost, stopDefrost) | ✅ 가능 | ❌ **불가** | 백엔드 차단 (403) |
| **출력 제어** (output) | ✅ 가능 | ❌ **불가** | 백엔드 차단 (403) |
| **장치 삭제** (initdevice) | ✅ 가능 | ❌ **불가** | 백엔드 차단 (403) |
| **알람 설정 변경** (saveAlarmSetting) | ✅ 가능 | ❌ **불가** | 백엔드 차단 (403) |
| **UI 입력 필드** | ✅ 활성 | ❌ **비활성** | 프론트엔드 (센서설정 페이지) |
| **저장/제어 버튼** | ✅ 활성 | ❌ **비활성** | 프론트엔드 (센서설정 페이지) |

### AdminController.setSensor 메서드 권한 체크

**setGu 값별 권한**:

| setGu 값 | 동작 | 주계정 | 부계정 |
|---------|------|--------|--------|
| **readparam** | 설정값 조회 (GET&type=1) | ✅ 허용 | ✅ **허용** |
| **readstatus** | 상태값 조회 (GET&type=2) | ✅ 허용 | ✅ **허용** |
| **param** | 파라미터 설정 변경 (SET) | ✅ 허용 | ❌ **차단** (403) |
| **defrost** | 강제제상 시작 | ✅ 허용 | ❌ **차단** (403) |
| **stopDefrost** | 강제제상 종료 | ✅ 허용 | ❌ **차단** (403) |
| **initdevice** | 장치 삭제 | ✅ 허용 | ❌ **차단** (403) |
| **output** | 출력 제어 | ✅ 허용 | ❌ **차단** (403) |

**백엔드 구현** (`AdminController.java:467-487`):
```java
// 부계정 권한 확인 - 설정 변경은 불가, 조회는 가능
String sessionUserId = (String) session.getAttribute("userId");
String parentUserId = (String) session.getAttribute("parentUserId");
boolean isSubAccount = (parentUserId != null && !parentUserId.isEmpty() && !parentUserId.equals(sessionUserId));

// setGu 값 확인 (조회 vs 설정 변경 구분)
String setGu = sensorMap != null ? String.valueOf(sensorMap.get("setGu")) : "";

// 부계정은 설정 변경 불가 (param, defrost, stopDefrost, initdevice, output 등)
if(isSubAccount) {
    boolean isReadOnlyRequest = "readparam".equals(setGu) || "readstatus".equals(setGu);
    
    if(!isReadOnlyRequest) {
        // 403 에러 반환
        return errorMap;
    }
}
```

### MQTT 토픽 구독 규칙 (부계정 지원)

**핵심 원칙**: 부계정은 센서의 **실제 소유자 ID(`sensor_id`)**로 MQTT 토픽을 구독해야 실시간 데이터를 수신할 수 있습니다.

#### 1. 메인 페이지 토픽 구독
**구현 위치**: `unified-mqtt-manager.js` - `pageTopicHandlers.main`

```javascript
'main': function() {
    // allowedSensorIds 배열의 모든 센서 소유자 ID로 토픽 구독
    var sensorIds = window.allowedSensorIds || [];
    
    if (sensorIds.length > 0) {
        // 각 센서 소유자 ID별로 토픽 구독 (중복 제거)
        var uniqueSensorIds = Array.from(new Set(sensorIds));
        uniqueSensorIds.forEach(function(sensorId) {
            var topic = 'HBEE/' + sensorId + '/+/+/DEV';
            subscribe(topic, handleSensorMessage);
        });
    }
}
```

**예시**:
- 부계정 `thepine7`이 주계정 `thepine`의 센서 4개 조회
- `window.allowedSensorIds = ['thepine']`
- 구독 토픽: `HBEE/thepine/+/+/DEV`

#### 2. 차트 페이지 토픽 구독
**구현 위치**: `unified-mqtt-manager.js` - `pageTopicHandlers.chart`

```javascript
'chart': function() {
    // 센서의 실제 소유자 ID로 토픽 구독 (부계정 지원)
    var sensorId = $('#sensorId').val(); // 센서 실제 소유자 ID
    var currentUserId = getCurrentUserId();
    
    if (sensorId) {
        // 센서 소유자 ID로 구독 (부계정이 주계정 센서를 조회하는 경우)
        var topic = 'HBEE/' + sensorId + '/+/+/DEV';
        subscribe(topic, handleSensorMessage);
    } else if (currentUserId) {
        // fallback: 현재 사용자 ID로 구독
        var topic = 'HBEE/' + currentUserId + '/+/+/DEV';
        subscribe(topic, handleSensorMessage);
    }
}
```

**예시**:
- 부계정 `thepine7`이 주계정 `thepine`의 센서 `0008DC755397` 조회
- `$('#sensorId').val() = 'thepine'`
- 구독 토픽: `HBEE/thepine/TC/0008DC755397/DEV` (와일드카드로 구독: `HBEE/thepine/+/+/DEV`)

#### 3. 센서설정 페이지 토픽 구독
**구현 위치**: `unified-mqtt-manager.js` - `pageTopicHandlers.sensorSetting`

```javascript
'sensorSetting': function() {
    // 센서의 실제 소유자 ID로 토픽 구독 (부계정 지원)
    var sensorId = $('#sensorId').val(); // 센서 실제 소유자 ID
    var currentUserId = getCurrentUserId();
    
    if (sensorId) {
        // 센서 소유자 ID로 구독 (부계정이 주계정 센서를 조회하는 경우)
        var topic = 'HBEE/' + sensorId + '/+/+/DEV';
        subscribe(topic, handleSensorMessage);
    } else if (currentUserId) {
        // fallback: 현재 사용자 ID로 구독
        var topic = 'HBEE/' + currentUserId + '/+/+/DEV';
        subscribe(topic, handleSensorMessage);
    }
}
```

**예시**:
- 부계정 `thepine7`이 주계정 `thepine`의 센서 `0008DC755397` 설정 조회
- `$('#sensorId').val() = 'thepine'`
- 구독 토픽: `HBEE/thepine/TC/0008DC755397/DEV`

### MQTT 메시지 필터링 규칙 (부계정 지원)

**구현 위치**: `unified-mqtt-manager.js` - `handleSensorMessage`

```javascript
// 1단계: 사용자 ID 필터링 (부계정 지원)
var currentUserId = getCurrentUserId();
var allowedSensorIds = window.allowedSensorIds || [];
var isAllowedUser = (userId === currentUserId) || (allowedSensorIds.indexOf(userId) >= 0);

if (!isAllowedUser) {
    console.log('사용자 ID 불일치로 메시지 필터링됨');
    return;
}
```

**핵심**: 메시지의 `userId`가 현재 사용자 ID 또는 `allowedSensorIds`에 포함되어 있으면 허용

### 센서설정 페이지 UI 비활성화 (부계정)

**구현 위치**: `sensorSetting.jsp` - `initializeSensorSetting` 함수

```javascript
function initializeSensorSetting() {
    // 부계정 판단: parentUserId가 null이 아니고 userId와 다르면 부계정
    var userGrade = '${userGrade}';
    var userId = '${userId}';
    var parentUserId = '${parentUserId}';
    var isSubAccount = (parentUserId && parentUserId !== '' && parentUserId !== 'null' && parentUserId !== userId);
    
    if(isSubAccount) {
        // 입력 필드 비활성화
        $('input[type="text"], select').prop('readonly', true).prop('disabled', true);
        
        // 저장 버튼 비활성화
        $('#saveSensor, #saveAlarm').prop('disabled', true);
        
        // 출력 제어 버튼 비활성화 (강제제상, 출력제어 등)
        $('#defrost, #stopDefrost, .out-btn').prop('disabled', true);
    }
}
```

### 페이지별 동작 요약

| 페이지 | 부계정 MQTT 구독 | 부계정 UI 제한 | 부계정 API 제한 |
|--------|------------------|----------------|----------------|
| **메인 페이지** | ✅ `allowedSensorIds`로 센서 소유자 ID 구독 | ❌ 제한 없음 | ✅ 조회만 가능 |
| **차트 페이지** | ✅ `$('#sensorId').val()`로 센서 소유자 ID 구독 | ❌ 제한 없음 | ✅ 조회만 가능 |
| **센서설정 페이지** | ✅ `$('#sensorId').val()`로 센서 소유자 ID 구독 | ✅ 입력 필드/버튼 비활성화 | ✅ 조회만 가능, 변경 차단 |

## MQTT 연결 안정성 및 호환성 규칙

### Paho MQTT JavaScript Client 호환성
- **라이브러리**: `mqttws31-min.js` (로컬 파일 사용)
- **CDN 사용 금지**: 외부 의존성 제거로 안정성 확보
- **지원되는 속성만 사용**: 호환성 문제 방지

### 지원되는 MQTT 연결 속성
```javascript
client.connect({
    onSuccess: onConnect,        // 연결 성공 콜백
    onFailure: onFailure,        // 연결 실패 콜백
    userName: 'hnt1',           // 사용자명
    password: 'abcde',          // 비밀번호
    cleanSession: true,         // 세션 정리
    keepAliveInterval: 60,      // Keep Alive 간격
    mqttVersion: 4,             // MQTT 버전
    timeout: 30,                // 연결 타임아웃
    useSSL: false               // SSL 사용 여부
});
```

### 지원되지 않는 속성 (사용 금지)
- ❌ **`reconnect: true`** - 라이브러리에서 지원하지 않음
- ❌ **`maxReconnectAttempts: 10`** - 라이브러리에서 지원하지 않음

### MQTT 연결 안정성 개선 (2025-08-02 구현)
- **지수 백오프 재연결**: 2초 → 4초 → 8초 → 16초 → 30초 (최대)
- **최대 재시도 횟수**: 10회 제한
- **연결 상태 표시**: 실시간 연결 시도 횟수 및 상태 표시
- **네트워크 상태 확인**: `navigator.onLine` 체크로 오프라인 시 연결 중단
- **자동 재연결**: 연결 끊김 시 자동 재연결 시도

### MQTT 연결 재시도 로직
```javascript
// 연결 재시도 카운터
var reconnectAttempts = 0;
var maxReconnectAttempts = 10;
var baseReconnectDelay = 2000; // 2초

// 지수 백오프 방식으로 재연결 지연 시간 계산
var delay = Math.min(baseReconnectDelay * Math.pow(2, reconnectAttempts - 1), 30000);
```
- ❌ **기타 문서화되지 않은 속성** - 호환성 문제 발생 가능

### 에러 차단 시스템 규칙
- **디버깅 시**: 에러 차단 시스템 완전 제거하여 모든 콘솔 메시지 확인
- **운영 시**: 선택적 에러 차단으로 MQTT 디버그 메시지만 허용
- **MQTT 디버그 메시지 키워드**:
  - `MQTT`, `연결`, `호스트`, `포트`, `클라이언트`
  - `=== MQTT`, `연결 성공`, `연결 실패`, `연결 끊김`

### 라이브러리 파일 관리
- **로컬 라이브러리**: `/js/mqttws31-min.js` 사용
- **백업 파일**: `mqtt_lib_original.js` - 정상 작동하는 원본 파일
- **현재 파일**: `mqtt_lib.js` - 커스텀 MQTT 라이브러리
- **복원 방법**: `mqtt_lib_original.js` → `mqtt_lib.js` 복사

### 문제 해결 가이드

#### MQTT 연결 문제 해결 순서
1. **라이브러리 호환성 확인**: 지원되지 않는 속성 제거
2. **에러 차단 시스템 확인**: MQTT 디버그 메시지 차단 여부 확인
3. **원본 파일 복원**: `mqtt_lib_original.js` → `mqtt_lib.js` 복사
4. **톰캣 서버 재시작**: Synology Container Manager에서 재시작
5. **콘솔 에러 확인**: 브라우저 개발자 도구에서 에러 메시지 확인

#### 자주 발생하는 문제 및 해결책
- **"Unknown property, reconnect"**: `reconnect` 속성 제거
- **"Unknown property, maxReconnectAttempts"**: `maxReconnectAttempts` 속성 제거
- **MQTT 디버그 메시지 안 보임**: 에러 차단 시스템 제거
- **GitHub 관련 에러**: 에러 차단 시스템으로 처리
- **MQTT 초기 연결 실패**: 지수 백오프 재연결 로직으로 해결
- **사이드바 사라짐**: CSS 미디어 쿼리 `display: none` 설정 확인

## 사용자 및 장치 관리 기능 구현 현황

### 1. 사용자 삭제 로직 구현 ✅

#### 부계정 vs 메인 사용자 구분 삭제
- **구현 위치**: `AdminController.java` - `deleteUser` 메서드
- **구현 내용**:
```java
// 삭제할 사용자의 등급 확인
UserInfo userInfo = loginService.getUserInfoByUserId(userId);
String userGrade = userInfo.getUserGrade();

if("B".equals(userGrade)) {
    // 부계정인 경우: 부계정 사용자 정보만 삭제 (장치 정보 보존)
    adminService.deleteSubUser(userId);
} else {
    // 메인 사용자인 경우: 모든 정보 삭제
    adminService.deleteUser(userId);
}
```

#### 삭제 로직 비교
| 사용자 등급 | 삭제되는 데이터 | 보존되는 데이터 | 구현 메서드 |
|------------|----------------|----------------|-------------|
| **B (부계정)** | `hnt_user` 테이블의 부계정 정보만 | 메인 사용자의 모든 장치 정보 및 센서 데이터 | `deleteSubUser()` |
| **A/U (메인)** | 모든 사용자 관련 데이터 | 없음 (완전 삭제) | `deleteUser()` |

#### 메인 사용자 삭제 시 삭제 순서
1. **사용자 센서 데이터 삭제**: `adminMapper.deleteUserSensorData(userId)`
2. **사용자 알림 데이터 삭제**: `adminMapper.deleteDeviceAlarm(alarmParam)`
3. **사용자 장치 설정 정보 삭제**: `adminMapper.deleteConfig(userId, "")`
4. **사용자 장치 기본 정보 삭제**: `adminMapper.deleteSensor(userId)`
5. **사용자 정보 삭제**: `adminMapper.deleteUser(userId)`

### 2. 장치 삭제 로직 구현 ✅

#### 완전 삭제 순서
- **구현 위치**: `DataServiceImpl.java` - `deleteSensorInfo` 메서드
- **삭제 순서**:
```java
// 1. 센서 데이터 삭제 (모든 센서 데이터 완전 삭제)
dataMapper.deleteSensorData(param);

// 2. 장치 관련 알림 데이터 삭제
adminMapper.deleteDeviceAlarm(param);

// 3. 장치 기본 정보 삭제
dataMapper.deleteSensorInfo(param);

// 4. 장치 설정 정보 삭제
adminMapper.deleteConfig(deviceVO.getUserId(), deviceVO.getSensorUuid());
```

#### 삭제되는 데이터 항목
- **센서 데이터**: `hnt_sensor_data` 테이블의 모든 센서 데이터
- **알림 데이터**: `hnt_alarm` 테이블의 장치 관련 알림
- **장치 기본 정보**: `hnt_sensor_info` 테이블의 장치 정보
- **장치 설정 정보**: `hnt_config` 테이블의 장치 설정

### 3. 부계정 권한 제한 기능 구현 ✅

#### 백엔드 권한 체크
- **구현 위치**: `DataController.java` - `deleteSensorInfo`, `updateSensorInfo` 메서드
- **권한 체크 로직**:
```java
// 부계정(B 등급) 사용자는 장치 삭제/수정 불가
if("B".equals(userGrade)) {
    resultMap.put("resultCode", "403");
    resultMap.put("resultMessage", "부계정 사용자는 장치 삭제 권한이 없습니다.");
    return resultMap;
}

// A(관리자) 또는 U(일반사용자)만 장치 삭제/수정 가능
if(!"A".equals(userGrade) && !"U".equals(userGrade)) {
    resultMap.put("resultCode", "403");
    resultMap.put("resultMessage", "장치 삭제 권한이 없습니다.");
    return resultMap;
}
```

#### 프론트엔드 권한 체크
- **메인 화면**: `main.jsp` - 설정 버튼 숨김
```jsp
<c:if test="${userGrade ne 'B'}">
    <a href="javascript:goSensorSetting_${item.sensor_uuid}();">
        <img src="/images/setting2.png" width="30" height="30">
    </a>
</c:if>
```

- **센서 설정 화면**: `sensorSetting.jsp` - 저장 버튼 권한 체크
```javascript
$('#save1').click(function() {
    if('${userGrade}' === 'B') {
        alert("부계정은 설정을 변경할 수 없습니다.");
        return;
    }
    saveSensorSetting();
});
```

### 4. 장치 전송 기능 구현 ✅

#### 기존 소유자 데이터 완전 삭제
- **구현 위치**: `LoginServiceImpl.java` - `insertSensorInfo` 메서드
- **전송 로직**:
```java
// 1. 다른 사용자가 해당 장치를 소유하고 있는지 확인
Map<String, Object> existingOwner = mqttMapper.getSensorInfoByUuid(checkParam);

if(existingOwner != null && existingOwner.size() > 0) {
    String existingUserId = String.valueOf(existingOwner.get("user_id"));
    
    // 2. 기존 소유자의 모든 데이터 삭제
    mqttMapper.deleteSensorInfoByUuid(checkParam);
    mqttMapper.deleteConfigByUuid(checkParam);
    mqttMapper.deleteSensorDataByUuid(checkParam);
    mqttMapper.deleteAlarmByUuid(checkParam);
    
    // 3. 새 사용자에게 장치 등록
    mqttMapper.insertSensorInfo(param);
}
```

#### 삭제되는 기존 소유자 데이터
- **장치 기본 정보**: `hnt_sensor_info` 테이블
- **장치 설정 정보**: `hnt_config` 테이블
- **센서 데이터**: `hnt_sensor_data` 테이블
- **알림 데이터**: `hnt_alarm` 테이블

### 5. DB 연결 최적화 구현 ✅

#### HikariCP 연결 풀 설정
- **구현 위치**: `application.yml`
- **최적화 설정**:
```yaml
hikari:
    max-lifetime: 900000          # 연결 최대 수명 (15분)
    connection-timeout: 30000     # 연결 타임아웃 (30초)
    minimum-idle: 5               # 최소 유휴 연결 수
    maximum-pool-size: 20         # 최대 연결 풀 크기
    idle-timeout: 600000          # 유휴 타임아웃 (10분)
    leak-detection-threshold: 60000  # 누수 감지 임계값 (1분)
```

#### 트랜잭션 관리
- **구현 위치**: `MqttApplicationRunner.java`
- **트랜잭션 메서드**:
```java
@Transactional
public void insertSensorDataWithTransaction(SensorVO sensorVO) {
    mqttMapper.insertSensorData(sensorVO);
}
```

### 6. 테스트 필요 항목 목록

#### 사용자 삭제 테스트
- [ ] **부계정 삭제 테스트**: `thepien7` 부계정 삭제 후 `thepine` 메인 사용자 데이터 보존 확인
- [ ] **메인 사용자 삭제 테스트**: 메인 사용자 삭제 시 모든 관련 데이터 완전 삭제 확인
- [ ] **삭제 로그 확인**: 각 단계별 삭제 로그 메시지 확인

#### 장치 삭제 테스트
- [ ] **장치 완전 삭제 테스트**: 장치 삭제 시 센서 데이터, 알림 데이터, 설정 정보 모두 삭제 확인
- [ ] **삭제 순서 확인**: 1→2→3→4 순서로 삭제되는지 확인
- [ ] **MQTT 장치 삭제**: DB 삭제 후 센서 자체 삭제 처리 확인

#### 부계정 권한 테스트
- [ ] **UI 권한 테스트**: 부계정 로그인 시 설정/삭제 버튼 숨김 확인
- [ ] **API 권한 테스트**: 부계정이 API 호출 시 403 에러 반환 확인
- [ ] **권한 로그 확인**: 권한 없는 사용자 시도 로그 기록 확인

#### 장치 전송 테스트
- [ ] **기존 소유자 확인**: 다른 사용자가 기존 장치 등록 시 기존 소유자 확인
- [ ] **데이터 삭제 확인**: 기존 소유자의 모든 데이터 완전 삭제 확인
- [ ] **새 소유자 등록**: 새 사용자에게 장치 정상 등록 확인

#### DB 성능 테스트
- [ ] **연결 풀 테스트**: HikariCP 연결 풀 정상 동작 확인
- [ ] **트랜잭션 테스트**: MQTT 데이터 저장 시 트랜잭션 정상 처리 확인
- [ ] **누수 감지 테스트**: 연결 누수 감지 기능 정상 동작 확인

## 🔥 중요: 실수 방지 규칙 (2025-08-03 업데이트)

### 1. MQTT 설정/상태 초기 동기화 관련
- **게이트**: 페이지 로딩 완료 + MQTT 연결 성공 이벤트 발생 후에만 초기 동기화 1회 수행
- **타이밍**:
  - `setSensor`(type=1): 조건 충족 후 0.5초에 1회
  - `getStatus`(type=2): 위 호출 후 2.0초(+2.0s)에 1회
- **중복 방지**: 초기 동기화는 1회만. 재연결 시 새 이벤트로 재수행
- **토픽 가드**: 발행 토픽에 `+`, `#` 포함 시 전송 금지, 1초 간격 최대 5회 재시도 후 포기

### 2. MQTT 메시지 필터링
- **3중 필터링 필수**: 사용자, 장치, actcode 모두 확인
  ```javascript
  // 1. 사용자 확인
  if(rcvTopicArr[1] !== currentUserId) return;
  // 2. 장치 UUID 확인  
  if(rcvTopicArr[3] !== targetDeviceUuid) return;
  // 3. actcode 확인 (setres만 처리)
  if(jsonObj.actcode !== "setres") return;
  ```
- **actcode 구분**: `live`는 현재온도, `setres`는 설정온도 응답

### 3. 사용자 정보 전달
- **URL 파라미터 읽기**: 페이지 로딩 시 URL에서 userId, userGrade 읽기
- **Hidden input 설정**: URL 파라미터로 hidden input 값 설정
- **페이지 이동 시**: 모든 네비게이션에서 userId, userGrade 전달

### 4. MQTT 토픽 구조 이해
- **sensor_id vs user_id**: 
  - `sensor_id`: 센서의 실제 소유자 (MQTT 토픽의 첫 번째 세그먼트)
  - `user_id`: 센서를 사용하는 사용자
  - 부계정(B 등급): `user_id ≠ sensor_id`
  - 메인 사용자(A/U 등급): `user_id = sensor_id`

### 5. 디버깅 규칙
- **MQTT 요청/응답 로깅**: 클라이언트와 서버 양쪽에 상세 로깅 추가
- **토픽 가시성 확인**: MQTT 클라이언트에서 토픽 발행 확인
- **타이밍 이슈**: 페이지 로딩과 MQTT 요청 타이밍 차이 주의

### 6. 백업 코드 참조
- **백업본 확인**: 수정 전 반드시 백업 코드와 비교
- **동일한 패턴 적용**: 백업본에서 작동하는 패턴을 그대로 적용
- **임의 변경 금지**: 작동하는 코드를 임의로 최적화하지 말 것

### 7. AI 동작 지침 (업데이트)
- 코드를 작성할 때 항상 타입 안전성을 고려하세요
- 에러 처리를 포함한 견고한 코드를 작성하세요
- 성능과 가독성을 모두 고려하세요
- 새로운 기능 추가 시 기존 코드와의 호환성을 확인하세요
- 새로운 코드 추가 시 기존 코드와 연관된 코드가 있는지 확인하세요
- **MQTT 관련 수정 시 반드시 백업본과 비교하세요**
- **setTimeout 값 변경 시 신중하게 검토하세요**
- **사용자 정보 전달 문제가 발생하면 URL 파라미터를 확인하세요**

## 📊 챠트데이터 페이지 상세 분석 (참고용)

### 페이지 접근 구조
- **URL**: `/chart/chart`
- **방식**: GET 요청
- **필수 파라미터**: `userId` (선택적)
- **사이드바 데이터**: `CommonController.addSidebarData()` 호출하여 DB에서 직접 조회

### 일간 데이터 조회 흐름
1. **DataController.chart() 메서드**: 실제 데이터 처리
   - 일간 데이터 조회: `param.put("gu", "d")`
   - `dailyList = dataService.selectSensorData(param)`
   - 데이터 포맷: `inst_dtm + "^" + sensor_value`

2. **DataMapper.xml - selectSensorData 쿼리**:
   ```sql
   -- 일간 데이터 조회 조건
   -- 기간: 현재 시간으로부터 1일 전까지
   -- 그룹화: 시간별, 30분 단위로 그룹화
   -- 집계: 평균값 계산 (round(avg(sensor_value), 1))
   -- 정렬: 날짜 내림차순, 시간 오름차순
   ```

### 프론트엔드 데이터 처리
1. **JSP에서 데이터 수신**: `<input type="hidden" id="daily" value="${daily}" />`
2. **JavaScript에서 데이터 파싱**: 
   - `daily.split(",")` → 배열로 분리
   - `dailyArr[i].split("^")` → 시간과 온도값 분리
3. **Chart.js로 시각화**: 라인 차트 생성

### 실시간 데이터 업데이트
1. **getData() 함수**: 0.5초마다 호출 (`startInterval(0.5, getData)`)
2. **MainController.getData()**: MQTT 서비스에서 데이터 조회
3. **MQTT 메시지 처리**: `rcvMsg()` 함수로 실시간 데이터 수신

### 데이터베이스 구조
- **hnt_sensor_data 테이블**: 센서 데이터 저장
- **필드**: user_id, sensor_id, uuid, sensor_value, inst_dtm

### 전체 데이터 흐름
1. 페이지 로딩 → `/chart/chart` 접근
2. 사용자 정보 조회 → `CommonController.addSidebarData()`
3. 일간 데이터 조회 → DB에서 1일간 데이터 조회하여 30분 단위로 평균값 계산
4. 데이터 파싱 → JSP에서 JavaScript로 파싱
5. 차트 렌더링 → Chart.js로 라인 차트 생성
6. 실시간 업데이트 → AJAX + MQTT로 현재 온도 실시간 표시

### 주요 특징
- **서버사이드 렌더링**: 페이지 로딩 시 DB에서 일간 데이터를 미리 조회
- **실시간 업데이트**: AJAX + MQTT로 현재 온도 실시간 표시
- **데이터 집계**: 30분 단위로 평균값 계산하여 차트 표시
- **설정온도 표시**: MQTT `setres` 응답으로 설정온도 표시
- **에러 처리**: 센서 연결 에러 시 "Error" 표시

## 📊 챠트데이터 페이지 상세 분석 (참고용)

### 페이지 접근 구조
- **URL**: `/chart/chart`
- **방식**: GET 요청
- **필수 파라미터**: `userId` (선택적)
- **사이드바 데이터**: `CommonController.addSidebarData()` 호출하여 DB에서 직접 조회

### 일간 데이터 조회 흐름
1. **DataController.chart() 메서드**: 실제 데이터 처리
   - 일간 데이터 조회: `param.put("gu", "d")`
   - `dailyList = dataService.selectSensorData(param)`
   - 데이터 포맷: `inst_dtm + "^" + sensor_value`

2. **DataMapper.xml - selectSensorData 쿼리**:
   ```sql
   -- 일간 데이터 조회 조건
   -- 기간: 현재 시간으로부터 1일 전까지
   -- 그룹화: 시간별, 30분 단위로 그룹화
   -- 집계: 평균값 계산 (round(avg(sensor_value), 1))
   -- 정렬: 날짜 내림차순, 시간 오름차순
   ```

### 프론트엔드 데이터 처리
1. **JSP에서 데이터 수신**: `<input type="hidden" id="daily" value="${daily}" />`
2. **JavaScript에서 데이터 파싱**: 
   - `daily.split(",")` → 배열로 분리
   - `dailyArr[i].split("^")` → 시간과 온도값 분리
3. **Chart.js로 시각화**: 라인 차트 생성

### 실시간 데이터 업데이트
1. **getData() 함수**: 0.5초마다 호출 (`startInterval(0.5, getData)`)
2. **MainController.getData()**: MQTT 서비스에서 데이터 조회
3. **MQTT 메시지 처리**: `rcvMsg()` 함수로 실시간 데이터 수신

### 데이터베이스 구조
- **hnt_sensor_data 테이블**: 센서 데이터 저장
- **필드**: user_id, sensor_id, uuid, sensor_value, inst_dtm

### 전체 데이터 흐름
1. 페이지 로딩 → `/chart/chart` 접근
2. 사용자 정보 조회 → `CommonController.addSidebarData()`
3. 일간 데이터 조회 → DB에서 1일간 데이터 조회하여 30분 단위로 평균값 계산
4. 데이터 파싱 → JSP에서 JavaScript로 파싱
5. 차트 렌더링 → Chart.js로 라인 차트 생성
6. 실시간 업데이트 → AJAX + MQTT로 현재 온도 실시간 표시

### 주요 특징
- **서버사이드 렌더링**: 페이지 로딩 시 DB에서 일간 데이터를 미리 조회
- **실시간 업데이트**: AJAX + MQTT로 현재 온도 실시간 표시
- **데이터 집계**: 30분 단위로 평균값 계산하여 차트 표시
- **설정온도 표시**: MQTT `setres` 응답으로 설정온도 표시
- **에러 처리**: 센서 연결 에러 시 "Error" 표시

## 프로젝트 폴더 구조
