<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ taglib prefix="x" uri="http://java.sun.com/jsp/jstl/xml" %>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ taglib prefix="sql" uri="http://java.sun.com/jsp/jstl/sql" %>
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>

<!DOCTYPE html>

<html lang="ko" class="">
<head>
  <meta charset="UTF-8">
  <!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><![endif]-->
  <title>H&T Solutions</title>
  <link rel="icon" href="/static/images/hntbi.png" type="image/png">
  <meta name="keywords" content="" />
  <meta name="description" content="" />
  <meta name="viewport" content="width=device-width">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <link rel="stylesheet" href="/static/css/templatemo_main.css">
  <link rel="stylesheet" href="/static/css/optimized_main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <style>
      /* 상태표시등 스타일 (설정페이지와 동일) */
      .status-indicator {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      }
      .status-indicator i {
        font-size: 16px;
        color: white;
      }
      .status-indicator.green { 
        background: #4CAF50; 
        box-shadow: 0 0 10px rgba(76, 175, 80, 0.3); 
      }
      .status-indicator.gray { 
        background: #9e9e9e; 
      }
      .status-indicator.red { 
        background: #f44336; 
        box-shadow: 0 0 10px rgba(244, 67, 54, 0.3); 
      }
      .status-indicator.active { 
        animation: pulse 2s infinite; 
      }
      
      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
      }
    </style>
</head>
<body>
<!-- 디버깅용 출력 -->
<!-- 세션 정보: userId=${userId}, userGrade=${userGrade}, loginUserId=${loginUserId} -->
<!-- 센서 정보: sensorId=${sensorId} -->

<input type="hidden" id="userId" name="userId" value="${userId}">
<input type="hidden" id="loginUserId" name="loginUserId" value="${loginUserId}">
<input type="hidden" id="userGrade" name="userGrade" value="${userGrade}">
<input type="hidden" id="sensorId" name="sensorId" value="${sensorId}">
<input type="hidden" id="token" name="token" value="${token}">
<input type="hidden" id="saveId" name="saveId" value="${saveId}">
<c:choose>
  <c:when test="${sensorList eq null}"></c:when>
  <c:otherwise>
    <c:forEach var="item" items="${sensorList}">

      <c:choose>
        <c:when test="${empty sensorId }">
          <input type="hidden" id="sensorUuid${item.sensor_uuid}" name="sensorUuid${item.sensor_uuid}" value="${item.sensor_uuid}" />
        </c:when>
        <c:otherwise>
          <input type="hidden" id="sensorUuid${item.sensor_uuid}" name="sensorUuid${item.sensor_uuid}" value="${item.sensor_uuid}" />
        </c:otherwise>
      </c:choose>
      <input type="hidden" id="sensorType" name="sensorType" value="${item.sensor_type}" />
      <input type="hidden" id="topicStr${item.sensor_uuid}" name="topicStr${item.sensor_uuid}" value="${item.topicStr}" />
      <input type="hidden" id="sensorList" name="sensorList" value="${sensorList}" />
      <input type="hidden" id="sensorArr" name="sensorArr" value="${sensorArr}" />
    </c:forEach>
  </c:otherwise>
</c:choose>

<div class="navbar navbar-inverse navbar-bg" role="navigation">
  <div class="navbar-header">
    		<div class="logo navbar-bg"><h1><a href="javascript:goMain();"><img src="/static/images/hntbi.png" width="70" height="32" alt="H&T Logo"></a></h1></div>
    <button type="button" class="navbar-toggle btn-toggle-bg" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
  </div>
</div>
<div class="template-page-wrapper">
  <div class="navbar-collapse collapse templatemo-sidebar">
    <ul class="templatemo-sidebar-menu">
      <li class="active"><a href="#"><i class="fa fa-home"></i>Dashboard</a></li>
      <li class="sub open">
          <ul class="sidebar-bg" style="height: 40px; padding-top: 10px">
            <strong>${userNm}님 안녕하세요.</strong>
          </ul>
        <c:if test="${userGrade eq 'A' || userGrade eq 'U'}">
          <a href="javascript:;">
            <i class="fa fa-database"></i> 관리 메뉴보기 <div class="pull-right"><span class="caret"></span></div>
          </a>
          <ul class="templatemo-submenu">
            <li><a href="javascript:goUserList();">사용자 관리</a></li>
          </ul>
          <ul class="templatemo-submenu">
            <li><a href="javascript:goCreateSub();">부계정 생성</a></li>
          </ul>
        </c:if>
      </li>
      <li><a href="" data-toggle="modal" data-target="#confirmModal"><i class="fa fa-sign-out"></i>로그아웃</a></li>
    </ul>
  </div><!--/.navbar-collapse -->

  <div class="templatemo-content-wrapper content-bg">
    <div class="templatemo-content content-bg">
      <h1><span class="text-light">Main</span></h1>
      
      <div class="templatemo-charts">
        <div class="row">
          <!--여기부터-->
          <c:choose>
            <c:when test="${sensorList eq null}">

            </c:when>
            <c:otherwise>
              <c:forEach var="item" items="${sensorList}">
              <div class="col-md-6 col-sm-6">
                <span class="btn btn-primary">
                  <c:if test="${userGrade ne 'B'}">
                    <a href="javascript:goSensorSetting_${item.sensor_uuid}();" class="icon-btn" title="장치설정"><i class="bi bi-gear-fill"></i></a>
                  </c:if>
                  <c:if test="${item.chart_type eq 'none'}">
                    <c:if test="${userGrade ne 'B'}">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</c:if>
                    <a href="javascript:goChartSetting_${item.sensor_uuid}();" class="icon-btn" title="차트설정"><i class="bi bi-graph-up"></i></a>
                  </c:if>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="javascript:goChartData_${item.sensor_uuid}();" class="icon-btn" title="차트데이터"><i class="bi bi-bar-chart-fill"></i></a>
                </span>
                <div class="panel panel-primary">
                  <div class="panel-heading"><strong>${item.sensor_name} <span id="deviceType${item.sensor_uuid}" style="font-size: 12px; color: #ccc;">(장치종류)</span></strong></div>
                  <input type="hidden" id="name${item.sensor_uuid}" name="name${item.sensor_uuid}" value="${item.sensor_name}">
                  <div class="panel-body">
                    <table class="table table-striped">
                      <thead>
                      <tr>
                        <td align="center" width="30%" style="background-color: #c7254e;"><strong><span style="color: #f0f8ff; ">구분</span></strong></td>
                        <td align="center" style="background-color: #c7254e;"><strong><span style="color: #f0f8ff; ">온도</span></strong></td>
                      </tr>
                      </thead>
                      <tbody>
                      <tr>
                        <td align="center">설정온도</td>
                        <td align="center">
                          <strong><span align="center" id="setTmp${item.sensor_uuid}" name="setTmp${item.sensor_uuid}" style="color: #4cae4c"></span></strong>
                        </td>
                      </tr>
                      <tr>
                        <td align="center" valign="middle">현재온도</td>
                        <td align="center">
                          <strong><span align="center" id="sensorVal${item.sensor_uuid}" name="sensorVal${item.sensor_uuid}" style="color: #c7254e"></span></strong>
                        </td>
                      </tr>
                      </tbody>
                    </table>
                    <table class="table table-striped">
                      <thead>
                      <tr>
                        <td align="center"><div id="status${item.sensor_uuid}" class="status-indicator green"><i class="bi bi-play-circle-fill"></i></div></td>
                        <td align="center"><div id="comp${item.sensor_uuid}" class="status-indicator gray"><i class="bi bi-gear-fill"></i></div></td>
                        <td align="center"><div id="defr${item.sensor_uuid}" class="status-indicator gray"><i class="bi bi-snow"></i></div></td>

                        <td align="center"><div id="fan${item.sensor_uuid}" class="status-indicator gray"><i class="bi bi-fan"></i></div></td>
                        <td align="center"><div id="error${item.sensor_uuid}" class="status-indicator gray"><i class="bi bi-exclamation-triangle-fill"></i></div></td>
                      </tr>
                      </thead>
                      <tbody>
                      <tr>
                                   <td width="20%" align="center" valign="middle" style="background-color: #c7254e;"><strong><span style="color: #f0f8ff; font-size:10pt;">운전</span></strong></td>
           <td width="20%" align="center" valign="middle" style="background-color: #c7254e;"><strong><span style="color: #f0f8ff; font-size:10pt;">콤프</span></strong></td>
           <td width="20%" align="center" valign="middle" style="background-color: #c7254e;"><strong><span id="defrostLabel${item.sensor_uuid}" style="color: #f0f8ff; font-size:10pt;">제상</span></strong></td>
              
           <td width="20%" align="center" valign="middle" style="background-color: #c7254e;"><strong><span style="color: #f0f8ff; font-size:10pt;">FAN</span></strong></td>
           <td width="20%" align="center" valign="middle" style="background-color: #c7254e;"><strong><span style="color: #f0f8ff; font-size:10pt;">이상</span></strong></td>
                      </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
                  <c:choose>
                    <c:when test="${item.chart_type eq 'none'}">
                    </c:when>
                    <c:otherwise>
                      <div class="col-md-6 col-sm-6">
                        <span class="btn btn-primary">
                          <c:if test="${userGrade ne 'B'}">
                            <a href="javascript:goChartSetting_${item.sensor_uuid}();" class="icon-btn" title="차트설정"><i class="bi bi-graph-up"></i></a>
                          </c:if>
                        </span>
                        <div class="panel panel-primary">
                          <div class="panel-heading">그래프</div>
                          <canvas id="sensorChart${item.sensor_uuid}" height=300" style="height:100%; width:100%"></canvas>
                        </div>
                      </div>
                    </c:otherwise>
                  </c:choose>
              </c:forEach>
            </c:otherwise>
          </c:choose>
          <!--여기까지-->
        </div>
      </div>
    </div>
  </div>
  <!-- Modal -->
  <div class="modal fade" id="confirmModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
          <h4 class="modal-title" id="myModalLabel">로그아웃 하시겠습니까?</h4>
        </div>
        <div class="modal-footer">
          <a href="javascript:logoutToLogin();" class="btn btn-primary">Yes</a>
          <button type="button" class="btn btn-default" data-dismiss="modal">No</button>
        </div>
      </div>
    </div>
  </div>
  <footer class="templatemo-footer">
    <div class="templatemo-copyright">
      <p>Copyright &copy; 2022 H&T Solutions</p>
    </div>
  </footer>
</div>

<!--script src="/js/jquery.min.js"></script-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
	<script src="/static/js/bootstrap.min.js"></script>
	<script src="/static/js/templatemo_script.js"></script>

<!--mqtt js-->
	<script src="/static/js/mqttws31-min.js"></script>
	<script src="/static/js/mqtt_lib.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-streaming@1.9.0"></script>
	<script src="/static/js/app-session.js"></script>
<script>
  startConnect();
  // 초기 동기화 디바운스: 로드+연결 후, 또는 복귀 시에도 안전하게 1회만 트리거
  var __pageReady = false;
  var __lastSyncScheduledAt = 0;
  function isMqttConnectedSafe() {
    try {
      return (typeof client !== 'undefined' && client && typeof client.isConnected === 'function' && client.isConnected());
    } catch(e) { return false; }
  }
  function requestInitialSyncOnce(reason) {
    if (!__pageReady) return;
    // MQTT 미연결이어도 서버측 /admin/setSensor가 발행/응답을 처리하므로 초기 동기화는 진행
    var now = Date.now();
    if (now - __lastSyncScheduledAt < 2000) {
      return; // 2초 내 중복 스케줄 방지
    }
    __lastSyncScheduledAt = now;
    setTimeout(function(){
      applyToAllUuids(function(uuid){
        if (typeof window['setSensor_' + uuid] === 'function') {
          window['setSensor_' + uuid]();
        }
      });
    }, 500);
    setTimeout(function(){
      applyToAllUuids(function(uuid){
        if (typeof window['getStatus_' + uuid] === 'function') {
          window['getStatus_' + uuid]();
        }
      });
    }, 2500);
  }
  window.addEventListener('load', function(){ __pageReady = true; });
  // MQTT 연결 성공 시(set by mqtt_lib.js)
  window.addEventListener('mqtt:connected', function(){ requestInitialSyncOnce('mqtt'); });

  // 페이지/연결 안정화 대기 후 동기화 (앱 복귀용)
  function waitForReadyThenSync(maxWaitMs) {
    var start = Date.now();
    (function poll(){
      var pageReady = (document.readyState === 'complete');
      var mqttReady = isMqttConnectedSafe();
      if (pageReady && mqttReady) {
        requestInitialSyncOnce('waitForReadyThenSync');
        return;
      }
      if (Date.now() - start > (maxWaitMs || 6000)) {
        // 타임아웃: MQTT 미연결이어도 초기 동기화 강제 수행 (서버가 처리)
        requestInitialSyncOnce('wait-timeout');
        return;
      }
      setTimeout(poll, 200);
    })();
  }
  // 아이들(가시성 숨김) 시 에러 체크 일시 정지 / 복귀 시 재개 및 초기 동기화
  document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        // 백그라운드 진입 즉시: 활성 플래그 내림, 모든 에러체크 타이머/카운터 일시 정지
        if (typeof isPageActive !== 'undefined') { isPageActive = false; }
      if (window.__errorTimers && window.__errorTimers.length) {
        window.__errorTimers.forEach(function(t){ clearInterval(t); });
        window.__errorTimers = [];
      }
        // 배경 진입 시점 기록
        try { window.backgroundStartTime = Date.now(); } catch(e) {}
        // 모든 장치에 에러 체크 유예 부여(앱은 여유 증가)
        var saveY = ($('#saveId').val() || 'N') === 'Y';
        var graceMsBg = saveY ? 40000 : 15000; // 앱은 더 길게 유예
        applyToAllUuids(function(uuid){ pauseError(uuid, graceMsBg); });
    } else {
      if (typeof checkTimeoutAndRedirect === 'function') {
        checkTimeoutAndRedirect();
      }
      // 복귀: 최근 수신 기준 초기화 후 에러 체크 재개
      if (typeof deviceLastDataTime !== 'undefined') {
        deviceLastDataTime = Date.now();
      }
        if (!window.__errorTimers) window.__errorTimers = [];
        // 복귀 즉시: 에러 카운터/상태 리셋 + MQTT 재연결
        // saveId=Y && 백그라운드 30초 초과 시: 첫 ain 수신까지 에러체크 완전 중지(최대 60초 타임아웃)
        var bgDur = 0; try { bgDur = Date.now() - (window.backgroundStartTime || 0); } catch(e) { bgDur = 0; }
        var isApp = ($('#saveId').val() || 'N') === 'Y';
        if (isApp && bgDur > 30000) {
          applyToAllUuids(function(uuid){ pauseError(uuid, 60000); }); // ain 수신 시 즉시 해제, 최대 60초
        } else {
          applyToAllUuids(function(uuid){ pauseError(uuid, 15000); });
        }
        if (typeof startConnect === 'function') { startConnect(); }
        // 복귀 직후 페이지/연결 안정화 대기 후 동기화
        waitForReadyThenSync(6000);
      // 메인은 각 장치별 에러 체크 타이머 재시작
      if (typeof startInterval === 'function') {
        // 모든 장치에 대해 에러 체크 타이머 재시작
        $('input[id^="sensorUuid"]').each(function(){
          var uuid = $(this).val();
          if (uuid) {
            // 각 장치별 에러 체크 함수가 존재하는지 확인 후 타이머 재시작
            var errorCheckFunc = window['chkError_' + uuid];
            if (typeof errorCheckFunc === 'function') {
              var handle = startInterval(5, errorCheckFunc);
              window.__errorTimers.push(handle);
            }
          }
        });
      }
      // 2초/4초 1회 초기 동기화는 센서설정/차트에 한정, 메인은 생략
    }
  });

    // 페이지 숨김 이벤트 보강: pagehide/blur에서도 즉시 비활성 처리
    window.addEventListener('pagehide', function(){
      if (typeof isPageActive !== 'undefined') { isPageActive = false; }
      if (window.__errorTimers && window.__errorTimers.length) { window.__errorTimers.forEach(function(t){ clearInterval(t); }); window.__errorTimers = []; }
      applyToAllUuids(function(uuid){ pauseError(uuid, 15000); });
    });
    window.addEventListener('blur', function(){
      if (typeof isPageActive !== 'undefined') { isPageActive = false; }
      if (window.__errorTimers && window.__errorTimers.length) { window.__errorTimers.forEach(function(t){ clearInterval(t); }); window.__errorTimers = []; }
      applyToAllUuids(function(uuid){ pauseError(uuid, 15000); });
    });

    // 장치별 에러 체크 일시정지 관리
    var errorPauseUntil = {};
    var resumeGate = {}; // 복귀 후 첫 ain 수신 전까지 에러 무시
    function pauseError(uuid, ms) {
      try {
        errorPauseUntil[uuid] = Date.now() + (ms || 15000);
        // 카운터/상태 리셋
        window['deviceErrorCounters_' + uuid] = 0;
        window['deviceErrorStates_' + uuid] = false;
        resumeGate[uuid] = true; // 복귀 게이트 활성화
      } catch(e) {}
    }
    function applyToAllUuids(callback) {
      try {
        $('input[id^="sensorUuid"]').each(function(){
          var uuid = $(this).val();
          if (uuid) { callback(uuid); }
        });
      } catch(e) {}
    }

        // 페이지 로딩 완료 시 상태 표시 초기화
      $(document).ready(function() {
        // 상태 표시 초기화
        initializeStatusIndicators();
        
        // MQTT 연결 시작
        if (typeof startConnect === 'function') {
          startConnect();
        }
      });
  
  

  // 함수 호이스팅을 위한 함수 선언
  function validateJson(str) {
    try {
      var json = JSON.parse(str);
      return (typeof json === 'object');
    } catch (e) {
      return false;
    }
  }

  function IsJsonString(str) {
    try {
      var json = JSON.parse(str);
      return (typeof json === 'object');
    } catch (e) {
      return false;
    }
  }

  function startInterval(seconds, callback, gu) {
    callback();
    return setInterval(callback, seconds * 1000);
  }

  function sendNoti(sensorVal, gu, uuid, type) {
    // saveid 설정 확인
    var currentSaveId = $('#saveId').val() || 'N';
    
    // saveid가 N인 경우 알림 전송하지 않음
    if (currentSaveId !== 'Y') {
      console.log('saveid N 설정: 알림 전송 건너뜀');
      return;
    }
    
    var userId = $('#userId').val();
    var sensorId = $('#sensorId').val();
    var token = $('#token').val();
    var sensorName = $('#name'+uuid).val();

    var sendData2 = {
      userId: userId,
      sensorId: sensorId,
      sensorUuid: uuid,
      sensorValue: sensorVal,
      token: token,
      name: gu,
      type: type
    }

    console.log('saveid Y 설정: 알림 전송 시작 - ' + gu + ' / ' + uuid);

    $.ajax({
      url: '/main/sendAlarm',
      async: true,
      type: 'POST',
      data: JSON.stringify(sendData2),
      dataType: 'json',
      contentType: 'application/json',
      success: function (result) {
        if (result.resultCode == "200") {
          console.log('알림 전송 성공');
        }
      },
      error: function (result) {
        console.log('알림 전송 실패');
      }
    });
  }

  // 공통 세션 검증 함수
  function validateSession() {
    var userId = $('#loginUserId').val() || $('#userId').val();
    var userGrade = $('#userGrade').val();
    
    if (!userId || userId === "" || userId === "null") {
      console.warn("세션이 만료되었습니다. 로그인 페이지로 이동합니다.");
      location.href = "/login/login";
      return false;
    }
    return true;
  }

  function goMain() {
    // 세션 정보 확인 후 메인 페이지로 이동
    var userId = $('#userId').val();
    var userGrade = $('#userGrade').val();
    
    if (!userId || userId === "" || userId === "null") {
      console.warn("사용자 정보가 없습니다. 로그인 페이지로 이동합니다.");
      location.href = "/login/login";
      return;
    }
    
    // 세션 정보를 URL 파라미터로 전달하여 안전한 페이지 이동
    location.href = "/main/main";
  }

  function goUserList() {
    var userId = $('#loginUserId').val() || $('#userId').val();
    var userGrade = $('#userGrade').val();
    
    if (!userId || userId === "" || userId === "null") {
      console.warn("사용자 정보가 없습니다. 로그인 페이지로 이동합니다.");
      location.href = "/login/login";
      return;
    }
    
    // 세션 정보를 URL 파라미터로 전달하여 안전한 페이지 이동
    location.href = "/admin/userList";
  }

  function goCreateSub() {
    var userId = $('#loginUserId').val() || $('#userId').val();
    var userGrade = $('#userGrade').val();
    
    if (!userId || userId === "" || userId === "null") {
      console.warn("사용자 정보가 없습니다. 로그인 페이지로 이동합니다.");
      location.href = "/login/login";
      return;
    }
    
    // 세션 정보를 URL 파라미터로 전달하여 안전한 페이지 이동
    location.href = "/admin/createSub";
  }

  // 공통 현재온도 처리 함수
  function updateCurrentTemperature(sensorUuid, value, isError) {
    if(isError) {
      $('#sensorVal'+sensorUuid).html('<font size="50px">Error</font>');
    } else {
      $('#sensorVal'+sensorUuid).html('<font size="50px">' + value + '°C</font>');
    }
  }
  
  // 완전한 부트스트랩 아이콘 기반 상태 표시 시스템
  
  // 1. 상태 표시 초기화 함수
  function initializeStatusIndicators() {
    <c:forEach var="item" items="${sensorList}">
      // ${item.sensor_uuid} 장치 상태 초기화
      updateStatus('${item.sensor_uuid}', 'gray');
      updateComp('${item.sensor_uuid}', 'gray');
      updateDefr('${item.sensor_uuid}', 'gray');
      updateFan('${item.sensor_uuid}', 'gray');
      updateError('${item.sensor_uuid}', 'gray');
    </c:forEach>
  }
  
  // 2. 통합 상태 업데이트 함수
  function updateAllStatuses(uuid, statusData) {
    try {
      // 운전 상태
      if (statusData.status !== undefined) {
        updateStatus(uuid, statusData.status);
      }
      
      // 콤프 상태
      if (statusData.comp !== undefined) {
        updateComp(uuid, statusData.comp);
      }
      
      // 제상 상태
      if (statusData.defr !== undefined) {
        updateDefr(uuid, statusData.defr);
      }
      
      // FAN 상태
      if (statusData.fan !== undefined) {
        updateFan(uuid, statusData.fan);
      }
      
      // 이상 상태
      if (statusData.error !== undefined) {
        updateError(uuid, statusData.error);
      }
    } catch (e) {
      console.error('Status update error:', e);
    }
  }

  // 장치별 에러 체크 함수 (실시간 온도 데이터 기반)
  function chkError(sensor_uuid) {
    // 복귀/백그라운드/연결상태/유예 게이트
    try {
      if (typeof isPageActive !== 'undefined' && isPageActive === false) return;
      if (typeof client !== 'undefined' && client && typeof client.isConnected === 'function' && !client.isConnected()) return;
      if (errorPauseUntil && errorPauseUntil[sensor_uuid] && Date.now() < errorPauseUntil[sensor_uuid]) return;
      if (resumeGate && resumeGate[sensor_uuid] === true) return; // 첫 ain 수신 전까지 무시
      if (typeof navigator !== 'undefined' && navigator && navigator.onLine === false) return;
    } catch(e) {}
    var deviceLastDataTime = window['deviceLastDataTime_' + sensor_uuid] || 0;
    var deviceErrorCounters = window['deviceErrorCounters_' + sensor_uuid] || 0;
    var deviceErrorStates = window['deviceErrorStates_' + sensor_uuid] || false;
    
    var currentTime = Date.now();
    var timeDiff = currentTime - deviceLastDataTime;
    
    // deviceLastDataTime이 0이거나 15초 동안 온도 데이터 미수신 시 에러 체크
    if ((deviceLastDataTime === 0 || timeDiff > 15000) && !deviceErrorStates) {
      deviceErrorCounters++;
      
      // 디버깅 로그 추가
      console.log(`[${sensor_uuid}] 에러 체크: deviceLastDataTime=${deviceLastDataTime}, timeDiff=${timeDiff}ms, counter=${deviceErrorCounters}`);
      
      // 3번 연속 미수신 시 에러 상태로 변경
      if (deviceErrorCounters >= 3) {
        deviceErrorStates = true;
        
        console.log(`[${sensor_uuid}] 통신에러 상태로 변경: ${deviceErrorCounters}번 연속 미수신`);
        
        // 상태표시등 업데이트 (Bootstrap Icons 사용)
        updateStatus(sensor_uuid, 'gray');
        $('#sensorVal'+sensor_uuid).html('<font size="50px">Error</font>');
        
        // 에러 상태일 때 그래프에도 Error 표시
        if (typeof window['yval_' + sensor_uuid] !== 'undefined') {
          window['yval_' + sensor_uuid] = 'Error';
        }
        
        sendNoti("0", "error", sensor_uuid, "0");

        // 상태 표시등 업데이트
                updateError(sensor_uuid, 'red');
    updateComp(sensor_uuid, 'gray');
    updateDefr(sensor_uuid, 'gray');
    updateFan(sensor_uuid, 'gray');
        
        // 상태 변수 업데이트
        window['deviceErrorStates_' + sensor_uuid] = true;
        window['deviceErrorCounters_' + sensor_uuid] = deviceErrorCounters;
      } else {
        // 카운터만 업데이트
        window['deviceErrorCounters_' + sensor_uuid] = deviceErrorCounters;
      }
    }
  }

  window.onload = function() {
    // 장치별 에러 체크 변수 초기화 (MQTT 연결 전에 먼저 초기화)
    <c:choose>
        <c:when test="${sensorList eq null}"></c:when>
        <c:otherwise>
            <c:forEach var="item" items="${sensorList}">
                // 장치별 에러 체크 변수 초기화
                window['deviceLastDataTime_${item.sensor_uuid}'] = 0;  // 0으로 초기화하여 에러 체크 즉시 시작
                window['deviceErrorCounters_${item.sensor_uuid}'] = 0;
                window['deviceErrorStates_${item.sensor_uuid}'] = false;
                window['deviceStatusStates_${item.sensor_uuid}'] = 'gray';
                window['deviceErrorDisplayStates_${item.sensor_uuid}'] = 'gray';
                window['deviceDinErrorStates_${item.sensor_uuid}'] = false;
                
                // 장치종류 초기값 설정
                window['deviceType_${item.sensor_uuid}'] = '0';  // 기본값: Cooler
                
                // 장치별 에러 체크 시작 - 한 번만 실행
                if (!window.__errorTimers) window.__errorTimers = [];
                var handle = setTimeout(function() { chkError('${item.sensor_uuid}'); }, 1000);
                window.__errorTimers.push(handle);

                var yval_${item.sensor_uuid} = 0;
            </c:forEach>
        </c:otherwise>
    </c:choose>
    
    // MQTT 연결 시작
    startConnect();
  };

  function rcvMsg(topic, message) {
    // MQTT 기반 실시간 데이터 처리 함수 호출
    handleMqttMessage(topic, message);
  }

  // JSP EL 값을 JavaScript 변수로 저장
  var currentUserId = '${userId}';
  var currentUserGrade = '${userGrade}';
  
  // 웹뷰 환경 감지 함수
  function isWebView() {
      return (typeof Android !== 'undefined' && Android.finish) || 
             (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.closeApp);
  }
  
  // 메인 페이지 뒤로가기 처리 설정
  function setupMainPageBackNavigation() {
                // 히스토리 관리는 DOM 로드 완료 후 지연 실행 (성능 최적화)
        setTimeout(function() {
            // 로그인 후 첫 진입인지 확인 (더 정확한 로직)
            var isFirstLogin = false;
            
            // 세션 스토리지를 사용하여 첫 진입 여부 확인
            var firstVisit = sessionStorage.getItem('mainPageFirstVisit');
            if (firstVisit === null || firstVisit === 'true') {
                isFirstLogin = true;
                sessionStorage.setItem('mainPageFirstVisit', 'false');
            }
            
            console.log('=== 히스토리 관리 디버깅 ===');
            console.log('isFirstLogin:', isFirstLogin);
            console.log('firstVisit:', firstVisit);
            console.log('history.length:', history.length);
            console.log('현재 URL:', window.location.href);
            
            // 히스토리 정리 (history.go() 제거하고 replaceState만 사용)
            if (!isFirstLogin) {
                console.log('히스토리 정리 실행 - replaceState 사용');
                // 히스토리를 메인 페이지만 남기고 정리
                history.replaceState({page: 'main'}, '메인', '/main/main');
                
                // 추가로 강제 히스토리 정리 실행
                setTimeout(function() {
                    forceCleanHistory();
                }, 50);
            } else {
                console.log('히스토리 정리 건너뛰기 - 첫 진입');
            }
            console.log('히스토리 상태 설정 완료');
        }, 200); // 200ms 지연으로 페이지 로딩 우선 (시간 증가)
        
        // 뒤로가기 시도 시 처리
        window.addEventListener('popstate', function(event) {
            // 웹뷰 환경 확인 후 처리
            if (isWebView()) {
                if (typeof Android !== 'undefined' && Android.finish) {
                    // Android 앱 종료
                    Android.finish();
                } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.closeApp) {
                    // iOS 앱 종료
                    window.webkit.messageHandlers.closeApp.postMessage('close');
                }
            } else {
                // 일반 브라우저에서는 페이지 새로고침으로 실시간 데이터 초기화
                window.location.reload(true);
            }
        });
        
        // 키보드 뒤로가기 단축키 처리
        document.addEventListener('keydown', function(event) {
            if (event.altKey && event.keyCode === 37) { // Alt + Left Arrow
                event.preventDefault();
                event.stopPropagation();
                
                if (isWebView()) {
                    if (typeof Android !== 'undefined' && Android.finish) {
                        Android.finish();
                    } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.closeApp) {
                        window.webkit.messageHandlers.closeApp.postMessage('close');
                    }
                } else {
                    window.location.reload(true);
                }
                return false;
            }
        });
        
        // 마우스 뒤로가기 버튼 처리
        document.addEventListener('mousedown', function(event) {
            if (event.button === 3 || event.button === 4) { // 뒤로가기/앞으로가기 버튼
                event.preventDefault();
                event.stopPropagation();
                
                if (isWebView()) {
                    if (typeof Android !== 'undefined' && Android.finish) {
                        Android.finish();
                    } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.closeApp) {
                        window.webkit.messageHandlers.closeApp.postMessage('close');
                    }
                } else {
                    window.location.reload(true);
                }
                return false;
            }
        });
  }
  
  // 메인 페이지 뒤로가기 처리 설정 실행 (모든 리소스 로드 완료 후)
  window.addEventListener('load', function() {
      console.log('=== 페이지 완전 로드 완료 ===');
      setupMainPageBackNavigation();
  });
  
  // 다른 페이지로 이동 시 히스토리 정리 (필요시 사용)
  function navigateToPage(url) {
      // 현재 히스토리 상태를 메인으로 정리
      history.replaceState({page: 'main'}, '메인', '/main/main');
      // 새 페이지로 이동
      window.location.href = url;
  }
  
  // 강력한 히스토리 정리 함수
  function forceCleanHistory() {
      console.log('=== 강제 히스토리 정리 시작 ===');
      console.log('현재 히스토리 길이:', history.length);
      
      // 히스토리를 메인 페이지만 남기고 완전히 정리
      if (history.length > 1) {
          // 모든 히스토리 엔트리를 메인으로 교체
          for (var i = 0; i < history.length; i++) {
              history.replaceState({page: 'main'}, '메인', '/main/main');
          }
          console.log('히스토리 강제 정리 완료');
      }
  }
  
  // 로그아웃 시 세션 스토리지 정리
  function clearMainPageSession() {
      sessionStorage.removeItem('mainPageFirstVisit');
  }
  
  // 페이지 이탈 시 강제 로그아웃을 수행하지 않습니다.
  // 내부 네비게이션 중 세션이 끊기는 문제를 방지하기 위함입니다.
  
  // 페이지 포커스 감지 (사용자가 다른 탭으로 이동하는 경우)
  var isPageActive = true;
  var lastActivityTime = Date.now();
  var backgroundStartTime = null;
  var currentSaveId = $('#saveId').val() || 'N'; // saveid 설정 확인
  
  console.log('현재 saveid 설정: ' + currentSaveId);
  
  document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
          // 페이지가 숨겨졌을 때 (다른 탭으로 이동)
          isPageActive = false;
          backgroundStartTime = Date.now();
          
          if (currentSaveId === 'Y') {
              // saveid가 Y인 경우: MQTT 연결 유지
              console.log('페이지 비활성화됨 - saveid Y 설정으로 MQTT 연결 유지 중');
              
              // MQTT 연결 상태 확인 및 유지
              if (typeof client !== 'undefined' && client.isConnected()) {
                  console.log('백그라운드에서 MQTT 연결 유지 중...');
              }
          } else {
              // saveid가 N인 경우: 기존 로직 유지
              console.log('페이지 비활성화됨 - saveid N 설정으로 기존 로직 적용');
          }
      } else {
          // 페이지가 다시 활성화되었을 때
          isPageActive = true;
          lastActivityTime = Date.now();
          console.log('페이지 활성화됨');
          
          if (currentSaveId === 'Y') {
              // saveid가 Y인 경우: 즉시 MQTT 연결 상태 확인 및 복구
              console.log('saveid Y 설정: 페이지 활성화 시 MQTT 연결 상태 확인');
              
              // MQTT 연결 상태 즉시 확인
              if (typeof client !== 'undefined') {
                  if (!client.isConnected()) {
                      console.log('MQTT 연결이 끊어져 있음 - 즉시 재연결 시도');
                      if (typeof startConnect === 'function') {
                          startConnect();
                      }
                  } else {
                      console.log('MQTT 연결 상태 정상 - 실시간 데이터 수신 확인');
                      // 연결은 되어 있지만 데이터가 오지 않는 경우를 대비해 재연결 시도
                      setTimeout(function() {
                          if (typeof startConnect === 'function') {
                              console.log('MQTT 연결 상태 재확인 및 필요시 재연결');
                              startConnect();
                          }
                      }, 2000); // 2초 후 재확인
                  }
              } else {
                  console.log('MQTT 클라이언트가 정의되지 않음 - 연결 시도');
                  if (typeof startConnect === 'function') {
                      startConnect();
                  }
              }
              
              // 백그라운드 시간이 30분 이상이었으면 추가 재연결 시도
              if (backgroundStartTime && (Date.now() - backgroundStartTime) > 1800000) { // 30분
                  console.log('30분 이상 백그라운드 상태였으므로 추가 MQTT 재연결 시도');
                  setTimeout(function() {
                      if (typeof startConnect === 'function') {
                          startConnect();
                      }
                  }, 5000); // 5초 후 추가 재연결
              }
          }
          
          backgroundStartTime = null;
      }
  });
  
  // 앱 포커스 관련 커스텀 로직 제거 (기본 동작만 유지)
  
  // 앱 인터페이스 함수 (앱에서 호출)
  window.appResume = function() {
      console.log('앱에서 resume 이벤트 호출됨');
      if (currentSaveId === 'Y') {
          console.log('saveid Y 설정: 앱 resume 시 MQTT 연결 복구');
          
          // 즉시 MQTT 연결 상태 확인 및 복구
          setTimeout(function() {
              if (typeof client !== 'undefined') {
                  if (!client.isConnected()) {
                      console.log('앱 resume 시 MQTT 연결 끊어짐 - 즉시 재연결');
                      if (typeof startConnect === 'function') {
                          startConnect();
                      }
                  } else {
                      console.log('앱 resume 시 MQTT 연결 상태 정상');
                  }
              } else {
                  console.log('앱 resume 시 MQTT 클라이언트 미정의 - 연결 시도');
                  if (typeof startConnect === 'function') {
                      startConnect();
                  }
              }
          }, 500); // 0.5초 후 확인
      }
  };
  
  // 주기적으로 페이지 활성 상태 확인 (saveid 설정에 따라 다르게 처리)
  setInterval(function() {
      if (!isPageActive) {
          var backgroundDuration = Date.now() - (backgroundStartTime || Date.now());
          
          if (currentSaveId === 'Y') {
              // saveid가 Y인 경우: 30분 이상 비활성 상태일 때만 로그아웃 처리
              if (backgroundDuration > 1800000) { // 30분
                  console.log('saveid Y 설정: 60분 이상 비활성 상태로 인한 로그아웃 처리');
                  performLogout();
              }
          } else {
              // saveid가 N인 경우: 기존 로직 (5분)
              if (backgroundDuration > 300000) { // 5분
                  console.log('saveid N 설정: 5분 이상 비활성 상태로 인한 로그아웃 처리');
                  performLogout();
              }
          }
      }
  }, currentSaveId === 'Y' ? 1800000 : 300000); // saveid Y: 30분, saveid N: 5분
  
  // 로그아웃 처리 함수
  function performLogout() {
      console.log('=== 로그아웃 처리 시작 ===');
      console.log('로그아웃 시간: ' + new Date().toLocaleString());
      
      // MQTT 연결 종료 (로그아웃 시에만)
      if (typeof logoutMqttDisconnect === 'function') {
          console.log('MQTT 연결 종료 함수 호출');
          logoutMqttDisconnect();
      } else {
          console.log('MQTT 연결 종료 함수가 정의되지 않음');
      }
      
      var xhr = new XMLHttpRequest();
      xhr.open('POST', '/login/logoutProcess', false);
      xhr.setRequestHeader('Content-Type', 'application/json');
      
      var logoutData = {
          userId: currentUserId
      };
      
      try {
          xhr.send(JSON.stringify(logoutData));
          console.log('페이지 비활성 상태로 인한 로그아웃 처리 완료');
          // 앱/브라우저 공통: 로그인 페이지로 이동
          window.location.href = '/login/login';
      } catch(e) {
          console.log('비활성 상태 로그아웃 처리 실패:', e);
      }
  }

  // 사용자 클릭 로그아웃(모달 Yes) 시: 항상 로그인 페이지로 이동
  function logoutToLogin() {
    var currentUserId = $('#loginUserId').val() || $('#userId').val() || '';
    $.ajax({
      url: '/login/logoutProcess',
      type: 'POST',
      async: false,
      data: JSON.stringify({ userId: currentUserId }),
      contentType: 'application/json',
      complete: function() {
        window.location.href = '/login/login';
      }
    });
  }

  // MQTT 기반 실시간 데이터 처리 함수
  function handleMqttMessage(topic, message) {
    try {
      if (!topic || !message) return;
      
      // MQTT 실시간 데이터 기반 상태표시등 업데이트
      updateStatusFromMqttMessage(topic, message);
      
      // JSON 메시지 파싱
      if (validateJson(message)) {
        var msg = JSON.parse(message);
        
        if (msg.actcode === 'live') {
          if (msg.name === 'ain') {
            // 온도 데이터 실시간 업데이트
            var uuid = topic.split("/")[3];
            updateCurrentTemperature(uuid, msg.value, msg.value === 'Error');
            
            // 데이터 수신 시점 기록 (에러 체크용)
            if (typeof window['deviceLastDataTime_' + uuid] !== 'undefined') {
              window['deviceLastDataTime_' + uuid] = Date.now();
            }
            
            // 에러 상태 해제
            if (msg.value !== 'Error') {
              var deviceErrorStates = window['deviceErrorStates_' + uuid] || false;
              if (deviceErrorStates) {
                window['deviceErrorStates_' + uuid] = false;
                window['deviceLastDataTime_' + uuid] = Date.now();
              }
            }
          }
        }
      }
    } catch (e) {
      console.error('MQTT 메시지 처리 오류:', e);
    }
  }
  
  // 실시간 온도 업데이트 함수
  function updateCurrentTemperature(uuid, value, isError) {
    try {
      var sensorValElement = $('#sensorVal' + uuid);
      if (sensorValElement.length > 0) {
        if (isError) {
          sensorValElement.html('<font size="50px">Error</font>');
        } else {
          sensorValElement.html('<font size="50px">' + value + '°C</font>');
        }
      }
      
      // 그래프 데이터 업데이트
      if (typeof window['yval_' + uuid] !== 'undefined') {
        window['yval_' + uuid] = isError ? 'Error' : parseFloat(value);
      }
    } catch (e) {
      console.error('온도 업데이트 오류:', e);
    }
  }
  
  // MQTT 실시간 데이터 기반 상태표시등 업데이트
  
  // MQTT 메시지에서 상태 정보 추출 및 업데이트
  function updateStatusFromMqttMessage(topic, message) {
    try {
      // JSON 파싱
      var jsonData = JSON.parse(message);
      
      // 토픽에서 UUID 추출
      var topicArr = topic.split('/');
      var uuid = topicArr[3]; // HBEE/userId/TC/uuid/DEV
      
      // 현재 사용자 확인
      var currentUserId = '${userId}';
      var topicUserId = topicArr[1];
      
      // 다른 사용자의 장치는 처리하지 않음
      if (topicUserId !== currentUserId) return;
      
      // actcode에 따른 처리
      switch (jsonData.actcode) {
        case "live":
          // 실시간 상태 데이터 처리
          switch (jsonData.name) {
            case "din":
              // Digital Input 상태 (Alarm, H/L, Counter, Freq 등)
              updateDinStatus(uuid, jsonData.value);
              break;
              
            case "output":
              // Output 상태 (COMP, DEF, FAN, DOUT, ROUT, AOUT 등)
              updateOutputStatus(uuid, jsonData.type, jsonData.ch, jsonData.value);
              break;
              
            case "ain":
              // Analog Input 상태 (현재온도 등)
              updateAinStatus(uuid, jsonData.value);
              break;
          }
          break;
          
        case "setres":
          // 설정값 응답 처리
          updateSensorSettings(uuid, jsonData);
          break;
      }
    } catch (e) {
      console.error('MQTT 상태 업데이트 오류:', e);
    }
  }
  
  // 센서 설정값 업데이트 (setres 메시지 처리)
  function updateSensorSettings(uuid, settings) {
    try {
      console.log('=== 센서 설정값 업데이트 ===');
      console.log('장치 UUID:', uuid);
      console.log('설정값:', settings);
      
      // 설정온도 (p01) 처리
      if (settings.p01 !== undefined) {
        var setTemp = parseFloat(settings.p01) / 10; // 160 → 16.0
        console.log('설정온도 파싱:', settings.p01, '→', setTemp + '°C');
        
                         // 설정온도 UI 업데이트
         var setTempElement = $('#setTmp' + uuid);
         if (setTempElement.length > 0) {
           setTempElement.html('<font size="20px" style="font-size: 8px !important;">' + setTemp + '°C</font>');
           console.log('설정온도 UI 업데이트 완료:', setTemp + '°C');
         } else {
           console.warn('설정온도 표시 요소를 찾을 수 없음:', 'setTmp' + uuid);
         }
      }
      
      // 다른 설정값들도 필요시 추가 처리
      if (settings.p02 !== undefined) {
        var hysteresis = parseFloat(settings.p02) / 10; // 10 → 1.0
        console.log('히스테리시스 편차:', hysteresis + '°C');
      }
      
      if (settings.p16 !== undefined) {
        var deviceType = settings.p16;
        console.log('장치종류:', deviceType === '1' ? 'Heater' : 'Cooler');
        
        // 장치종류에 따른 제상 라벨 변경
        var defrostLabel = $('#defrostLabel' + uuid);
        if (defrostLabel.length > 0) {
          if (deviceType === '1') {
            defrostLabel.text('가열');
          } else {
            defrostLabel.text('제상');
          }
        }
      }
      
      console.log('=== 센서 설정값 업데이트 완료 ===');
    } catch (e) {
      console.error('센서 설정값 업데이트 오류:', e);
    }
  }
  
  // Digital Input 상태 업데이트
  function updateDinStatus(uuid, value) {
    try {
      // value가 1이면 이상 상태, 0이면 정상 상태
      if (value === "1" || value === 1) {
        // 이상 상태: 빨간색
        updateError(uuid, 'red');
        // DIN 이상 상태 플래그 설정
        window['deviceDinErrorStates_' + uuid] = true;
      } else {
        // 정상 상태: 회색
        updateError(uuid, 'gray');
        // DIN 이상 상태 플래그 해제
        window['deviceDinErrorStates_' + uuid] = false;
      }
    } catch (e) {
      console.error('DIN 상태 업데이트 오류:', e);
    }
  }
  
  // Output 상태 업데이트
  function updateOutputStatus(uuid, type, ch, value) {
    try {
      // type에 따른 상태 업데이트
      switch (type) {
        case "1": // COMP (콤프)
          updateComp(uuid, value === "1" ? 'red' : 'gray');
          break;
        case "2": // DEF (제상)
          updateDefr(uuid, value === "1" ? 'red' : 'gray');
          break;
        case "3": // FAN
          updateFan(uuid, value === "1" ? 'red' : 'gray');
          break;
        case "4": // DOUT (Digital Output)
          // 필요시 추가 처리
          break;
        case "5": // ROUT (Relay Output)
          // 필요시 추가 처리
          break;
        case "6": // AOUT (Analog Output)
          // 필요시 추가 처리
          break;
      }
    } catch (e) {
      console.error('Output 상태 업데이트 오류:', e);
    }
  }
  
  // Analog Input 상태 업데이트 (현재온도)
  function updateAinStatus(uuid, value) {
    try {
      // 온도값이 "Error"인 경우
      if (value === "Error" || value === "error") {
        // 온도 표시를 "Error"로 설정
        $('#sensorVal' + uuid).html('<font size="50px">Error</font>');
        // 에러 상태 체크
        chkError(uuid);
      } else {
        // 정상 온도값 표시
        $('#sensorVal' + uuid).html('<font size="50px">' + value + '°C</font>');
        // 에러 상태 해제
        clearError(uuid);
      }
    } catch (e) {
      console.error('AIN 상태 업데이트 오류:', e);
    }
  }
  
  // 에러 상태 해제
  function clearError(uuid) {
    try {
      // 에러 카운터 초기화
      window['deviceErrorCounters_' + uuid] = 0;
      // 에러 상태 해제
      window['deviceErrorStates_' + uuid] = false;
      // 마지막 데이터 시간 업데이트
      window['deviceLastDataTime_' + uuid] = Date.now();
    } catch (e) {
      console.error('에러 상태 해제 오류:', e);
    }
  }

  // 상태별 업데이트 함수들 (설정페이지와 동일한 방식)
  
  // 운전 상태 업데이트
  function updateStatus(uuid, status) {
    try {
      var elementId = 'status' + uuid;
      var element = $('#' + elementId);
      if (element.length > 0) {
        // CSS 클래스 변경 (설정페이지와 동일)
        element.removeClass('green gray red').addClass('status-indicator ' + status);
        
        // 부트스트랩 아이콘 유지하면서 상태에 따른 아이콘 변경
        var iconClass = status === 'green' ? 'bi-play-circle-fill' : 'bi-pause-circle-fill';
        element.find('i').removeClass().addClass('bi ' + iconClass);
      }
    } catch (e) {
      console.error('Status update error:', e);
    }
  }

  // 콤프 상태 업데이트
  function updateComp(uuid, status) {
    try {
      var elementId = 'comp' + uuid;
      var element = $('#' + elementId);
      if (element.length > 0) {
        element.removeClass('green gray red').addClass('status-indicator ' + status);
        // 부트스트랩 아이콘 유지
        element.find('i').removeClass().addClass('bi bi-gear-fill');
      }
    } catch (e) {
      console.error('Comp update error:', e);
    }
  }

  // 제상 상태 업데이트
  function updateDefr(uuid, status) {
    try {
      var elementId = 'defr' + uuid;
      var element = $('#' + elementId);
      if (element.length > 0) {
        element.removeClass('green gray red').addClass('status-indicator ' + status);
        // 장치종류에 따라 아이콘 결정 (설정페이지와 동일)
        var deviceType = window['deviceType_' + uuid] || '0';
        var iconClass = deviceType === '1' ? 'bi-thermometer-half' : 'bi-snow';
        element.find('i').removeClass().addClass('bi ' + iconClass);
      }
    } catch (e) {
      console.error('Defr update error:', e);
    }
  }

  // FAN 상태 업데이트
  function updateFan(uuid, status) {
    try {
      var elementId = 'fan' + uuid;
      var element = $('#' + elementId);
      if (element.length > 0) {
        element.removeClass('green gray red').addClass('status-indicator ' + status);
        // 부트스트랩 아이콘 유지
        element.find('i').removeClass().addClass('bi bi-fan');
      }
    } catch (e) {
      console.error('Fan update error:', e);
    }
  }

  // 이상 상태 업데이트
  function updateError(uuid, status) {
    try {
      var elementId = 'error' + uuid;
      var element = $('#' + elementId);
      if (element.length > 0) {
        element.removeClass('green gray red').addClass('status-indicator ' + status);
        // 부트스트랩 아이콘 유지
        element.find('i').removeClass().addClass('bi bi-exclamation-triangle-fill');
      }
    } catch (e) {
      console.error('Error update error:', e);
    }
  }

  // MQTT 연결 성공 후 초기 설정값 요청
  function requestInitialSettingsAfterConnection() {
    try {
      console.log('=== MQTT 연결 성공 후 초기 설정값 요청 시작 ===');
      
      <c:forEach var="item" items="${sensorList}">
        // ${item.sensor_uuid} 장치 설정값 요청
        var topic = 'HBEE/${item.user_id}/TC/${item.sensor_uuid}/SER';
        var message = 'GET&type=1'; // 설정값 요청
        
        console.log('초기 설정값 요청:', topic, message);
        
        // MQTT 클라이언트가 연결되어 있으면 메시지 발행
        if (typeof client !== 'undefined' && client.isConnected()) {
          client.publish(topic, message);
          console.log('설정값 요청 메시지 발행 완료:', topic);
        } else {
          console.warn('MQTT 클라이언트가 연결되지 않음, 설정값 요청 건너뜀:', topic);
        }
      </c:forEach>
      
      console.log('=== 초기 설정값 요청 완료 ===');
    } catch (e) {
      console.error('초기 설정값 요청 오류:', e);
    }
  }
  
  // MQTT 연결 성공 이벤트 리스너 추가
  $(document).ready(function() {
    // MQTT 연결 성공 이벤트 리스너
    $(document).on('mqtt:connected', function() {
      console.log('=== MQTT 연결 성공 이벤트 수신! ===');
      
      // 연결 성공 후 2초 지연하여 초기 설정값 요청
      setTimeout(function() {
        requestInitialSettingsAfterConnection();
      }, 2000);
    });
  });
</script>
<c:choose>
  <c:when test="${sensorList eq null}"></c:when>
  <c:otherwise>
    <c:forEach var="item" items="${sensorList}">
    <script type="text/javascript">
      var chartColors_${item.sensor_uuid} = {
        red: 'rgb(255, 99, 132)',
        orange: 'rgb(255, 159, 64)',
        yellow: 'rgb(255, 205, 86)',
        green: 'rgb(75, 192, 192)',
        blue: 'rgb(54, 162, 235)',
        purple: 'rgb(153, 102, 255)',
        grey: 'rgb(201, 203, 207)'
      };

      var titleStr_${item.sensor_uuid} = "";
      var xval_${item.sensor_uuid} = 0;
      var yval_${item.sensor_uuid} = 0;
      var setp01_${item.sensor_uuid} = 0;
      var outputVal_${item.sensor_uuid} = "";
      var name_${item.sensor_uuid} = "";

      // MQTT 실시간 데이터만 사용하므로 getData AJAX 함수 제거됨

      function chkError_${item.sensor_uuid}() {
        // 비활성/재연결 유예 중이면 에러 체크 중단
        try {
          if (typeof isPageActive !== 'undefined' && isPageActive === false) return;
          if (typeof client !== 'undefined' && client && typeof client.isConnected === 'function' && !client.isConnected()) return;
          if (errorPauseUntil && errorPauseUntil['${item.sensor_uuid}'] && Date.now() < errorPauseUntil['${item.sensor_uuid}']) return;
          if (resumeGate && resumeGate['${item.sensor_uuid}'] === true) return; // 첫 ain 수신 전까지 무시
          if (typeof navigator !== 'undefined' && navigator && navigator.onLine === false) return; // 오프라인 시 무시
        } catch(e) {}
        var sendData = {
          userId: $('#userId').val(),
          sensorId: $('#sensorId').val(),
          sensorUuid: '${item.sensor_uuid}',
          userToken: $('#token').val()
        }

        //console.log('${item.sensor_uuid}' + " : " + sendData);

        $.ajax({
          url: '/admin/chkError',
          async: true,
          type: 'POST',
          data: JSON.stringify(sendData),
          dataType: 'json',
          contentType: 'application/json',
          success: function (result) {
            console.log("chkerror : " + result.resultCode + "/" + result.resultMessage);
            if (result.resultCode == "200") {
              if(result.resultMessage == "Error") {
                // 1분 이내 인입된 데이터가 0인 경우 통신 오류로 판단하여 알람 발송
                // 깜빡임 방지를 위해 현재 상태와 다른 경우에만 변경
                // 부트스트랩 아이콘으로 상태 표시
                updateStatus('${item.sensor_uuid}', 'gray');
                $('#sensorVal${item.sensor_uuid}').html('<font size="50px">Error</font>');
                sendNoti("0", "error", '${item.sensor_uuid}', "0");

                // 통신 에러 발생 시 이전까지의 표시는 모두 원복 처리 (깜빡임 방지)
                                // 부트스트랩 아이콘으로 상태 표시
                updateError('${item.sensor_uuid}', 'red');
                updateComp('${item.sensor_uuid}', 'gray');
                updateDefr('${item.sensor_uuid}', 'gray');
                updateFan('${item.sensor_uuid}', 'gray');

              } else {
                //console.log("chkerrror : ok");
                // 깜빡임 방지를 위해 현재 상태와 다른 경우에만 변경
                // 부트스트랩 아이콘으로 상태 표시
                updateStatus('${item.sensor_uuid}', 'green');
                updateError('${item.sensor_uuid}', 'gray');
                sendNoti("0", "error_release", '${item.sensor_uuid}', "0");
              }
            }
          },
          error: function (result) {

          }
        });
      }

      function setSensor_${item.sensor_uuid}() {
        // 토픽 유효성 검사: 와일드카드(+,#) 포함 시 호출 보류 후 재시도
        var currentTopic_${item.sensor_uuid} = $('#topicStr${item.sensor_uuid}').val();
        if (!currentTopic_${item.sensor_uuid} || currentTopic_${item.sensor_uuid}.indexOf('+') >= 0 || currentTopic_${item.sensor_uuid}.indexOf('#') >= 0) {
          window['topicRetry_${item.sensor_uuid}'] = (window['topicRetry_${item.sensor_uuid}'] || 0) + 1;
          if (window['topicRetry_${item.sensor_uuid}'] <= 5) {
            setTimeout(function(){ setSensor_${item.sensor_uuid}(); }, 1000);
          } else {
            console.warn('setSensor - 잘못된 topicStr 감지, 재시도 중단:', currentTopic_${item.sensor_uuid});
          }
          return;
        }

        var sendData2 = {
          userId: $('#userId').val(),
          topicStr: currentTopic_${item.sensor_uuid},
          setGu: "readparam",
          type: "1"  // type=1: parameter 요청
        }

        $.ajax({
          url: '/admin/setSensor',
          async: true,
          type: 'POST',
          data: JSON.stringify(sendData2),
          dataType: 'json',
          contentType: 'application/json',
          success: function (result) {
            if (result.resultCode == "200") {

              if(result.resultMsg) {
                if(IsJsonString(result.resultMsg)) {
                  var jsonObj = JSON.parse(result.resultMsg);
                  var rcvTopic = result.rcvTopic;
                  ////console.log(rcvTopic);
                  var rcvTopicArr = Array();

                  if(rcvTopic) {
                    rcvTopicArr = rcvTopic.split("/");
                    if(rcvTopicArr[3] == '${item.sensor_uuid}') {
                      setp01_${item.sensor_uuid} = jsonObj.p01;
                    }
                  }
                }
              }

            }
          },
          error: function (reuslt) {

          }
        });
      }

      function getStatus_${item.sensor_uuid}() {
        // 토픽 유효성 검사: 와일드카드(+,#) 포함 시 호출 보류 후 재시도
        var currentTopic_${item.sensor_uuid} = $('#topicStr${item.sensor_uuid}').val();
        if (!currentTopic_${item.sensor_uuid} || currentTopic_${item.sensor_uuid}.indexOf('+') >= 0 || currentTopic_${item.sensor_uuid}.indexOf('#') >= 0) {
          window['topicRetry_${item.sensor_uuid}'] = (window['topicRetry_${item.sensor_uuid}'] || 0) + 1;
          if (window['topicRetry_${item.sensor_uuid}'] <= 5) {
            setTimeout(function(){ getStatus_${item.sensor_uuid}(); }, 1000);
          } else {
            console.warn('getStatus - 잘못된 topicStr 감지, 재시도 중단:', currentTopic_${item.sensor_uuid});
          }
          return;
        }

        var sendData2 = {
          userId: $('#userId').val(),
          topicStr: currentTopic_${item.sensor_uuid},
          setGu: "readstatus",
          type: "2"  // type=2: status 요청
        }

        $.ajax({
          url: '/admin/setSensor',
          async: true,
          type: 'POST',
          data: JSON.stringify(sendData2),
          dataType: 'json',
          contentType: 'application/json',
          success: function (result) {
            if (result.resultCode == "200") {
            }
          },
          error: function (result) {

          }
        });
      }

      function onRefresh_${item.sensor_uuid}(chart) {
        var now = Date.now();
        var currentValue = 0;

        // MQTT에서 받은 현재 온도 값 사용
        if (typeof yval_${item.sensor_uuid} !== 'undefined' && yval_${item.sensor_uuid} !== null) {
          // Error 상태가 아닐 때만 그래프에 데이터 추가
          if (yval_${item.sensor_uuid} !== 'Error' && yval_${item.sensor_uuid} !== 'error') {
            currentValue = parseFloat(yval_${item.sensor_uuid});
            
            chart.data.datasets.forEach(function(dataset) {
              dataset.data.push({
                x: now,
                y: currentValue
              });
              
              // 데이터 포인트가 너무 많아지면 오래된 데이터 제거 (최대 50개 유지)
              if (dataset.data.length > 50) {
                dataset.data.shift();
              }
            });
          } else {
            // Error 상태일 때는 그래프에 데이터 추가하지 않음
            console.log("그래프 업데이트 스킵 - 장치: ${item.sensor_uuid}, 상태: Error");
          }
        }
      }

      function setSensorId_${item.sensor_uuid}(str) {
        if(str !== "") {
          $('#sensorUuid${item.sensor_uuid}').val(str);
          location.href = "/main/main?sensorId=" + str;
        }
      }

      function goSensorSetting_${item.sensor_uuid}() {
        var sensorUuid = $('#sensorUuid${item.sensor_uuid}').val();
        //startDisconnect();

        // URL 파라미터 없이 장치설정 페이지로 이동
        location.href = "/admin/sensorSetting?sensorUuid="+sensorUuid;
      }

      function goChartSetting_${item.sensor_uuid}() {
        var sensorUuid = $('#sensorUuid${item.sensor_uuid}').val();
        //startDisconnect();

        // URL 파라미터 없이 차트설정 페이지로 이동 (세션 사용)
        location.href = "/admin/chartSetting?sensorUuid="+sensorUuid;
      }

      function goChartData_${item.sensor_uuid}() {
        var sensorUuid = $('#sensorUuid${item.sensor_uuid}').val();
        //startDisconnect();

        // URL 파라미터 최소화 (세션 사용)
        location.href = "/data/chart?sensorUuid="+sensorUuid;
      }

      var chart_type;
      chart_type = '${item.chart_type}';

      if(chart_type != "none") {
        var color_${item.sensor_uuid} = Chart.helpers.color;
        var config_${item.sensor_uuid} = {
          type: '${item.chart_type}',
          data: {
            datasets: [{
              label: titleStr_${item.sensor_uuid},
              backgroundColor: color_${item.sensor_uuid}(chartColors_${item.sensor_uuid}.red).alpha(0.5).rgbString(),
              borderColor: chartColors_${item.sensor_uuid}.red,
              fill: false,
              lineTension: 0,
              pointRadius: 3,
              data: []
            }
            ]
          },
          options: {
            responsive: false,
            title: {
              display: true,
              text: '${item.chart_type} chart'
            },
            scales: {
              xAxes: [{
                type: 'realtime',
                realtime: {
                  duration: 45000,  // 45초로 조정하여 더 촘촘한 간격
                  refresh: 5000,
                  delay: 0,
                  onRefresh: onRefresh_${item.sensor_uuid}
                },
                ticks: {
                  maxTicksLimit: 15,  // 15개의 틱 표시 (더 촘촘한 간격)
                  maxRotation: 45,    // 라벨 회전 각도
                  minRotation: 0
                }
              }],
              yAxes: [{
                scaleLabel: {
                  display: true,
                  labelString: 'value'
                }
              }]
            },
            tooltips: {
              enabled: true,
              mode: 'nearest',
              intersect: false
            },
            hover: {
              mode: 'nearest',
              intersect: false
            }
          }
        };

        var ctx_${item.sensor_uuid} = document.getElementById('sensorChart${item.sensor_uuid}').getContext('2d');
        window.myChart_${item.sensor_uuid} = new Chart(ctx_${item.sensor_uuid}, config_${item.sensor_uuid});

        $('#sensorChart${item.sensor_uuid}').show();
      }

    </script>
    </c:forEach>
  </c:otherwise>
</c:choose>

    <script>
      // 함수 호이스팅을 위한 함수 선언
      function validateJson(str) {
        try {
          var json = JSON.parse(str);
          return (typeof json === 'object');
        } catch (e) {
          return false;
        }
      }

      function IsJsonString(str) {
        try {
          var json = JSON.parse(str);
          return (typeof json === 'object');
        } catch (e) {
          return false;
        }
      }

      function startInterval(seconds, callback, gu) {
        callback();
        return setInterval(callback, seconds * 1000);
      }

      function sendNoti(sensorVal, gu, uuid, type) {
        // saveid 설정 확인
        var currentSaveId = $('#saveId').val() || 'N';
        
        // saveid가 N인 경우 알림 전송하지 않음
        if (currentSaveId !== 'Y') {
          console.log('saveid N 설정: 알림 전송 건너뜀');
          return;
        }
        
        var userId = $('#userId').val();
        var sensorId = $('#sensorId').val();
        var token = $('#token').val();
        var sensorName = $('#name'+uuid).val();

        var sendData2 = {
          userId: userId,
          sensorId: sensorId,
          sensorUuid: uuid,
          sensorValue: sensorVal,
          token: token,
          name: gu,
          type: type
        }

        console.log('saveid Y 설정: 알림 전송 시작 - ' + gu + ' / ' + uuid);

        $.ajax({
          url: '/main/sendAlarm',
          async: true,
          type: 'POST',
          data: JSON.stringify(sendData2),
          dataType: 'json',
          contentType: 'application/json',
          success: function (result) {
            if (result.resultCode == "200") {
              console.log('알림 전송 성공');
            }
          },
          error: function (result) {
            console.log('알림 전송 실패');
          }
        });
      }

      // 공통 세션 검증 함수
      function validateSession() {
        var userId = $('#loginUserId').val() || $('#userId').val();
        var userGrade = $('#userGrade').val();
        
        if (!userId || userId === "" || userId === "null") {
          console.warn("세션이 만료되었습니다. 로그인 페이지로 이동합니다.");
          location.href = "/login/login";
          return false;
        }
        return true;
      }

      function goMain() {
        // 세션 정보 확인 후 메인 페이지로 이동
        var userId = $('#userId').val();
        var userGrade = $('#userGrade').val();
        
        if (!userId || userId === "" || userId === "null") {
          console.warn("사용자 정보가 없습니다. 로그인 페이지로 이동합니다.");
          location.href = "/login/login";
          return;
        }
        
        // 세션 정보를 URL 파라미터로 전달하여 안전한 페이지 이동
        location.href = "/main/main";
      }

      function goUserList() {
        var userId = $('#loginUserId').val() || $('#userId').val();
        var userGrade = $('#userGrade').val();
        
        if (!userId || userId === "" || userId === "null") {
          console.warn("사용자 정보가 없습니다. 로그인 페이지로 이동합니다.");
          location.href = "/login/login";
          return;
        }
        
        // 세션 정보를 URL 파라미터로 전달하여 안전한 페이지 이동
        location.href = "/admin/userList";
      }

      function goCreateSub() {
        var userId = $('#loginUserId').val() || $('#userId').val();
        var userGrade = $('#userGrade').val();
        
        if (!userId || userId === "" || userId === "null") {
          console.warn("사용자 정보가 없습니다. 로그인 페이지로 이동합니다.");
          location.href = "/login/login";
          return;
        }
        
        // 세션 정보를 URL 파라미터로 전달하여 안전한 페이지 이동
        location.href = "/admin/createSub";
      }

      // 공통 현재온도 처리 함수
      function updateCurrentTemperature(sensorUuid, value, isError) {
        if(isError) {
          $('#sensorVal'+sensorUuid).html('<font size="50px">Error</font>');
        } else {
          $('#sensorVal'+sensorUuid).html('<font size="50px">' + value + '°C</font>');
        }
      }
      
      // 완전한 부트스트랩 아이콘 기반 상태 표시 시스템
      
      // 1. 상태 표시 초기화 함수
      function initializeStatusIndicators() {
        <c:forEach var="item" items="${sensorList}">
          // ${item.sensor_uuid} 장치 상태 초기화
          updateStatus('${item.sensor_uuid}', 'gray');
          updateComp('${item.sensor_uuid}', 'gray');
          updateDefr('${item.sensor_uuid}', 'gray');
          updateFan('${item.sensor_uuid}', 'gray');
          updateError('${item.sensor_uuid}', 'gray');
        </c:forEach>
      }
      
      // 2. 통합 상태 업데이트 함수
      function updateAllStatuses(uuid, statusData) {
        try {
          // 운전 상태
          if (statusData.status !== undefined) {
            updateStatus(uuid, statusData.status);
          }
          
          // 콤프 상태
          if (statusData.comp !== undefined) {
            updateComp(uuid, statusData.comp);
          }
          
          // 제상 상태
          if (statusData.defr !== undefined) {
            updateDefr(uuid, statusData.defr);
          }
          
          // FAN 상태
          if (statusData.fan !== undefined) {
            updateFan(uuid, statusData.fan);
          }
          
          // 이상 상태
          if (statusData.error !== undefined) {
            updateError(uuid, statusData.error);
          }
        } catch (e) {
          console.error('Status update error:', e);
        }
      }

      // 장치별 에러 체크 함수 (실시간 온도 데이터 기반)
      function chkError(sensor_uuid) {
        // 복귀/백그라운드/연결상태/유예 게이트
        try {
          if (typeof isPageActive !== 'undefined' && isPageActive === false) return;
          if (typeof client !== 'undefined' && client && typeof client.isConnected === 'function' && !client.isConnected()) return;
          if (errorPauseUntil && errorPauseUntil[sensor_uuid] && Date.now() < errorPauseUntil[sensor_uuid]) return;
          if (resumeGate && resumeGate[sensor_uuid] === true) return; // 첫 ain 수신 전까지 무시
          if (typeof navigator !== 'undefined' && navigator && navigator.onLine === false) return;
        } catch(e) {}
        var deviceLastDataTime = window['deviceLastDataTime_' + sensor_uuid] || 0;
        var deviceErrorCounters = window['deviceErrorCounters_' + sensor_uuid] || 0;
        var deviceErrorStates = window['deviceErrorStates_' + sensor_uuid] || false;
        
        var currentTime = Date.now();
        var timeDiff = currentTime - deviceLastDataTime;
        
        // deviceLastDataTime이 0이거나 15초 동안 온도 데이터 미수신 시 에러 체크
        if ((deviceLastDataTime === 0 || timeDiff > 15000) && !deviceErrorStates) {
          deviceErrorCounters++;
          
          // 디버깅 로그 추가
          console.log(`[${sensor_uuid}] 에러 체크: deviceLastDataTime=${deviceLastDataTime}, timeDiff=${timeDiff}ms, counter=${deviceErrorCounters}`);
          
          // 3번 연속 미수신 시 에러 상태로 변경
          if (deviceErrorCounters >= 3) {
            deviceErrorStates = true;
            
            console.log(`[${sensor_uuid}] 통신에러 상태로 변경: ${deviceErrorCounters}번 연속 미수신`);
            
            // 상태표시등 업데이트 (Bootstrap Icons 사용)
            updateStatus(sensor_uuid, 'gray');
            $('#sensorVal'+sensor_uuid).html('<font size="50px">Error</font>');
            
            // 에러 상태일 때 그래프에도 Error 표시
            if (typeof window['yval_' + sensor_uuid] !== 'undefined') {
              window['yval_' + sensor_uuid] = 'Error';
            }
            
            sendNoti("0", "error", sensor_uuid, "0");

            // 상태 표시등 업데이트
                    updateError(sensor_uuid, 'red');
        updateComp(sensor_uuid, 'gray');
        updateDefr(sensor_uuid, 'gray');
        updateFan(sensor_uuid, 'gray');
            
            // 상태 변수 업데이트
            window['deviceErrorStates_' + sensor_uuid] = true;
            window['deviceErrorCounters_' + sensor_uuid] = deviceErrorCounters;
          } else {
            // 카운터만 업데이트
            window['deviceErrorCounters_' + sensor_uuid] = deviceErrorCounters;
          }
        }
      }

      window.onload = function() {
        // MQTT 연결 시작
        startConnect();
        
        <c:choose>
            <c:when test="${sensorList eq null}"></c:when>
            <c:otherwise>
                <c:forEach var="item" items="${sensorList}">
                    // 장치별 에러 체크 변수 초기화
                    window['deviceLastDataTime_${item.sensor_uuid}'] = 0;  // 0으로 초기화하여 에러 체크 즉시 시작
                    window['deviceErrorCounters_${item.sensor_uuid}'] = 0;
                    window['deviceErrorStates_${item.sensor_uuid}'] = false;
                    window['deviceStatusStates_${item.sensor_uuid}'] = 'gray';
                    window['deviceErrorDisplayStates_${item.sensor_uuid}'] = 'gray';
                    window['deviceDinErrorStates_${item.sensor_uuid}'] = false;
                    
                    // MQTT 실시간 데이터만 사용하므로 getData AJAX 호출 제거
                    // setTimeout(function() {
                    //   startInterval(0.5, getData_${item.sensor_uuid}, "1");
                    // }, 500);

                    // 장치별 에러 체크 시작 (5초마다)
                    setTimeout(function() {
                      if (!window.__errorTimers) window.__errorTimers = [];
                      var handle = startInterval(5, function() { chkError('${item.sensor_uuid}'); }, "2");
                      window.__errorTimers.push(handle);
                    }, 1000); // 3000ms → 1000ms로 단축하여 빠른 에러 감지

                    // 초기 요청은 mqtt:connected 이벤트 리스너에서 일괄 처리

                    var yval_${item.sensor_uuid} = 0;
                </c:forEach>
            </c:otherwise>
        </c:choose>
      };

      function rcvMsg(topic, message) {
        // MQTT 기반 실시간 데이터 처리 함수 호출
        handleMqttMessage(topic, message);
      }

      // JSP EL 값을 JavaScript 변수로 저장
      var currentUserId = '${userId}';
      var currentUserGrade = '${userGrade}';
      
      // 웹뷰 환경 감지 함수
      function isWebView() {
          return (typeof Android !== 'undefined' && Android.finish) || 
                 (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.closeApp);
      }
      
      // 메인 페이지 뒤로가기 처리 설정
      function setupMainPageBackNavigation() {
                    // 히스토리 관리는 DOM 로드 완료 후 지연 실행 (성능 최적화)
          setTimeout(function() {
              // 로그인 후 첫 진입인지 확인 (더 정확한 로직)
              var isFirstLogin = false;
              
              // 세션 스토리지를 사용하여 첫 진입 여부 확인
              var firstVisit = sessionStorage.getItem('mainPageFirstVisit');
              if (firstVisit === null || firstVisit === 'true') {
                  isFirstLogin = true;
                  sessionStorage.setItem('mainPageFirstVisit', 'false');
              }
              
              console.log('=== 히스토리 관리 디버깅 ===');
              console.log('isFirstLogin:', isFirstLogin);
              console.log('firstVisit:', firstVisit);
              console.log('history.length:', history.length);
              console.log('현재 URL:', window.location.href);
              
              // 히스토리 정리 (history.go() 제거하고 replaceState만 사용)
              if (!isFirstLogin) {
                  console.log('히스토리 정리 실행 - replaceState 사용');
                  // 히스토리를 메인 페이지만 남기고 정리
                  history.replaceState({page: 'main'}, '메인', '/main/main');
                  
                  // 추가로 강제 히스토리 정리 실행
                  setTimeout(function() {
                      forceCleanHistory();
                  }, 50);
              } else {
                  console.log('히스토리 정리 건너뛰기 - 첫 진입');
              }
              console.log('히스토리 상태 설정 완료');
          }, 200); // 200ms 지연으로 페이지 로딩 우선 (시간 증가)
          
          // 뒤로가기 시도 시 처리
          window.addEventListener('popstate', function(event) {
              // 웹뷰 환경 확인 후 처리
              if (isWebView()) {
                  if (typeof Android !== 'undefined' && Android.finish) {
                      // Android 앱 종료
                      Android.finish();
                  } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.closeApp) {
                      // iOS 앱 종료
                      window.webkit.messageHandlers.closeApp.postMessage('close');
                  }
              } else {
                  // 일반 브라우저에서는 페이지 새로고침으로 실시간 데이터 초기화
                  window.location.reload(true);
              }
          });
          
          // 키보드 뒤로가기 단축키 처리
          document.addEventListener('keydown', function(event) {
              if (event.altKey && event.keyCode === 37) { // Alt + Left Arrow
                  event.preventDefault();
                  event.stopPropagation();
                  
                  if (isWebView()) {
                      if (typeof Android !== 'undefined' && Android.finish) {
                          Android.finish();
                      } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.closeApp) {
                          window.webkit.messageHandlers.closeApp.postMessage('close');
                      }
                  } else {
                      window.location.reload(true);
                  }
                  return false;
              }
          });
          
          // 마우스 뒤로가기 버튼 처리
          document.addEventListener('mousedown', function(event) {
              if (event.button === 3 || event.button === 4) { // 뒤로가기/앞으로가기 버튼
                  event.preventDefault();
                  event.stopPropagation();
                  
                  if (isWebView()) {
                      if (typeof Android !== 'undefined' && Android.finish) {
                          Android.finish();
                      } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.closeApp) {
                          window.webkit.messageHandlers.closeApp.postMessage('close');
                      }
                  } else {
                      window.location.reload(true);
                  }
                  return false;
              }
          });
      }
      
      // 메인 페이지 뒤로가기 처리 설정 실행 (모든 리소스 로드 완료 후)
      window.addEventListener('load', function() {
          console.log('=== 페이지 완전 로드 완료 ===');
          setupMainPageBackNavigation();
      });
      
      // 다른 페이지로 이동 시 히스토리 정리 (필요시 사용)
      function navigateToPage(url) {
          // 현재 히스토리 상태를 메인으로 정리
          history.replaceState({page: 'main'}, '메인', '/main/main');
          // 새 페이지로 이동
          window.location.href = url;
      }
      
      // 강력한 히스토리 정리 함수
      function forceCleanHistory() {
          console.log('=== 강제 히스토리 정리 시작 ===');
          console.log('현재 히스토리 길이:', history.length);
          
          // 히스토리를 메인 페이지만 남기고 완전히 정리
          if (history.length > 1) {
              // 모든 히스토리 엔트리를 메인으로 교체
              for (var i = 0; i < history.length; i++) {
                  history.replaceState({page: 'main'}, '메인', '/main/main');
              }
              console.log('히스토리 강제 정리 완료');
          }
      }
      
      // 로그아웃 시 세션 스토리지 정리
      function clearMainPageSession() {
          sessionStorage.removeItem('mainPageFirstVisit');
      }
      
      // 페이지 이탈 시 강제 로그아웃을 수행하지 않습니다.
      // 내부 네비게이션 중 세션이 끊기는 문제를 방지하기 위함입니다.
      
      // 페이지 포커스 감지 (사용자가 다른 탭으로 이동하는 경우)
      var isPageActive = true;
      var lastActivityTime = Date.now();
      var backgroundStartTime = null;
      var currentSaveId = $('#saveId').val() || 'N'; // saveid 설정 확인
      
      console.log('현재 saveid 설정: ' + currentSaveId);
      
      document.addEventListener('visibilitychange', function() {
          if (document.hidden) {
              // 페이지가 숨겨졌을 때 (다른 탭으로 이동)
              isPageActive = false;
              backgroundStartTime = Date.now();
              
              if (currentSaveId === 'Y') {
                  // saveid가 Y인 경우: MQTT 연결 유지
                  console.log('페이지 비활성화됨 - saveid Y 설정으로 MQTT 연결 유지 중');
                  
                  // MQTT 연결 상태 확인 및 유지
                  if (typeof client !== 'undefined' && client.isConnected()) {
                      console.log('백그라운드에서 MQTT 연결 유지 중...');
                  }
              } else {
                  // saveid가 N인 경우: 기존 로직 유지
                  console.log('페이지 비활성화됨 - saveid N 설정으로 기존 로직 적용');
              }
          } else {
              // 페이지가 다시 활성화되었을 때
              isPageActive = true;
              lastActivityTime = Date.now();
              console.log('페이지 활성화됨');
              
              if (currentSaveId === 'Y') {
                  // saveid가 Y인 경우: 즉시 MQTT 연결 상태 확인 및 복구
                  console.log('saveid Y 설정: 페이지 활성화 시 MQTT 연결 상태 확인');
                  
                  // MQTT 연결 상태 즉시 확인
                  if (typeof client !== 'undefined') {
                      if (!client.isConnected()) {
                          console.log('MQTT 연결이 끊어져 있음 - 즉시 재연결 시도');
                          if (typeof startConnect === 'function') {
                              startConnect();
                          }
                      } else {
                          console.log('MQTT 연결 상태 정상 - 실시간 데이터 수신 확인');
                          // 연결은 되어 있지만 데이터가 오지 않는 경우를 대비해 재연결 시도
                          setTimeout(function() {
                              if (typeof startConnect === 'function') {
                                  console.log('MQTT 연결 상태 재확인 및 필요시 재연결');
                                  startConnect();
                              }
                          }, 2000); // 2초 후 재확인
                      }
                  } else {
                      console.log('MQTT 클라이언트가 정의되지 않음 - 연결 시도');
                      if (typeof startConnect === 'function') {
                          startConnect();
                      }
                  }
                  
                  // 백그라운드 시간이 30분 이상이었으면 추가 재연결 시도
                  if (backgroundStartTime && (Date.now() - backgroundStartTime) > 1800000) { // 30분
                      console.log('30분 이상 백그라운드 상태였으므로 추가 MQTT 재연결 시도');
                      setTimeout(function() {
                          if (typeof startConnect === 'function') {
                              startConnect();
                          }
                      }, 5000); // 5초 후 추가 재연결
                  }
              }
              
              backgroundStartTime = null;
          }
      });
      
      // 앱 포커스 관련 커스텀 로직 제거 (기본 동작만 유지)
      
      // 앱 인터페이스 함수 (앱에서 호출)
      window.appResume = function() {
          console.log('앱에서 resume 이벤트 호출됨');
          if (currentSaveId === 'Y') {
              console.log('saveid Y 설정: 앱 resume 시 MQTT 연결 복구');
              
              // 즉시 MQTT 연결 상태 확인 및 복구
              setTimeout(function() {
                  if (typeof client !== 'undefined') {
                      if (!client.isConnected()) {
                          console.log('앱 resume 시 MQTT 연결 끊어짐 - 즉시 재연결');
                          if (typeof startConnect === 'function') {
                              startConnect();
                          }
                      } else {
                          console.log('앱 resume 시 MQTT 연결 상태 정상');
                      }
                  } else {
                      console.log('앱 resume 시 MQTT 클라이언트 미정의 - 연결 시도');
                      if (typeof startConnect === 'function') {
                          startConnect();
                      }
                  }
              }, 500); // 0.5초 후 확인
          }
      };
      
      // 주기적으로 페이지 활성 상태 확인 (saveid 설정에 따라 다르게 처리)
      setInterval(function() {
          if (!isPageActive) {
              var backgroundDuration = Date.now() - (backgroundStartTime || Date.now());
              
              if (currentSaveId === 'Y') {
                  // saveid가 Y인 경우: 30분 이상 비활성 상태일 때만 로그아웃 처리
                  if (backgroundDuration > 1800000) { // 30분
                      console.log('saveid Y 설정: 60분 이상 비활성 상태로 인한 로그아웃 처리');
                      performLogout();
                  }
              } else {
                  // saveid가 N인 경우: 기존 로직 (5분)
                  if (backgroundDuration > 300000) { // 5분
                      console.log('saveid N 설정: 5분 이상 비활성 상태로 인한 로그아웃 처리');
                      performLogout();
                  }
              }
          }
      }, currentSaveId === 'Y' ? 1800000 : 300000); // saveid Y: 30분, saveid N: 5분
      
      // 로그아웃 처리 함수
      function performLogout() {
          console.log('=== 로그아웃 처리 시작 ===');
          console.log('로그아웃 시간: ' + new Date().toLocaleString());
          
          // MQTT 연결 종료 (로그아웃 시에만)
          if (typeof logoutMqttDisconnect === 'function') {
              console.log('MQTT 연결 종료 함수 호출');
              logoutMqttDisconnect();
          } else {
              console.log('MQTT 연결 종료 함수가 정의되지 않음');
          }
          
          var xhr = new XMLHttpRequest();
          xhr.open('POST', '/login/logoutProcess', false);
          xhr.setRequestHeader('Content-Type', 'application/json');
          
          var logoutData = {
              userId: currentUserId
          };
          
          try {
              xhr.send(JSON.stringify(logoutData));
              console.log('페이지 비활성 상태로 인한 로그아웃 처리 완료');
              // 앱/브라우저 공통: 로그인 페이지로 이동
              window.location.href = '/login/login';
          } catch(e) {
              console.log('비활성 상태 로그아웃 처리 실패:', e);
          }
      }

      // 사용자 클릭 로그아웃(모달 Yes) 시: 항상 로그인 페이지로 이동
      function logoutToLogin() {
        var currentUserId = $('#loginUserId').val() || $('#userId').val() || '';
        $.ajax({
          url: '/login/logoutProcess',
          type: 'POST',
          async: false,
          data: JSON.stringify({ userId: currentUserId }),
          contentType: 'application/json',
          complete: function() {
            window.location.href = '/login/login';
          }
        });
      }

      // MQTT 기반 실시간 데이터 처리 함수
      function handleMqttMessage(topic, message) {
        try {
          if (!topic || !message) return;
          
          // MQTT 실시간 데이터 기반 상태표시등 업데이트
          updateStatusFromMqttMessage(topic, message);
          
          // JSON 메시지 파싱
          if (validateJson(message)) {
            var msg = JSON.parse(message);
            
            if (msg.actcode === 'live') {
              if (msg.name === 'ain') {
                // 온도 데이터 실시간 업데이트
                var uuid = topic.split("/")[3];
                updateCurrentTemperature(uuid, msg.value, msg.value === 'Error');
                
                // 데이터 수신 시점 기록 (에러 체크용)
                if (typeof window['deviceLastDataTime_' + uuid] !== 'undefined') {
                  window['deviceLastDataTime_' + uuid] = Date.now();
                }
                
                // 에러 상태 해제
                if (msg.value !== 'Error') {
                  var deviceErrorStates = window['deviceErrorStates_' + uuid] || false;
                  if (deviceErrorStates) {
                    window['deviceErrorStates_' + uuid] = false;
                    window['deviceLastDataTime_' + uuid] = Date.now();
                  }
                }
              }
            }
          }
        } catch (e) {
          console.error('MQTT 메시지 처리 오류:', e);
        }
      }
      
      // 실시간 온도 업데이트 함수
      function updateCurrentTemperature(uuid, value, isError) {
        try {
          var sensorValElement = $('#sensorVal' + uuid);
          if (sensorValElement.length > 0) {
            if (isError) {
              sensorValElement.html('<font size="50px">Error</font>');
            } else {
              sensorValElement.html('<font size="50px">' + value + '°C</font>');
            }
          }
          
          // 그래프 데이터 업데이트
          if (typeof window['yval_' + uuid] !== 'undefined') {
            window['yval_' + uuid] = isError ? 'Error' : parseFloat(value);
          }
        } catch (e) {
          console.error('온도 업데이트 오류:', e);
        }
      }
      
      // MQTT 메시지에서 상태 정보 추출 및 업데이트
      function updateStatusFromMqttMessage(topic, message) {
        try {
          // JSON 파싱
          var jsonData = JSON.parse(message);
          
          // 토픽에서 UUID 추출
          var topicArr = topic.split('/');
          var uuid = topicArr[3]; // HBEE/userId/TC/uuid/DEV
          
          // 현재 사용자 확인
          var currentUserId = '${userId}';
          var topicUserId = topicArr[1];
          
          // 다른 사용자의 장치는 처리하지 않음
          if (topicUserId !== currentUserId) return;
          
          // actcode에 따른 처리
          switch (jsonData.actcode) {
            case "live":
              // 실시간 상태 데이터 처리
              switch (jsonData.name) {
                case "din":
                  // Digital Input 상태 (Alarm, H/L, Counter, Freq 등)
                  updateDinStatus(uuid, jsonData.value);
                  break;
                  
                case "output":
                  // Output 상태 (COMP, DEF, FAN, DOUT, ROUT, AOUT 등)
                  updateOutputStatus(uuid, jsonData.type, jsonData.ch, jsonData.value);
                  break;
                  
                case "ain":
                  // Analog Input 상태 (현재온도 등)
                  updateAinStatus(uuid, jsonData.value);
                  break;
              }
              break;
              
            case "setres":
              // 설정값 응답 처리
              updateSensorSettings(uuid, jsonData);
              break;
          }
        } catch (e) {
          console.error('MQTT 상태 업데이트 오류:', e);
        }
      }
      
      // 센서 설정값 업데이트 (setres 메시지 처리)
      function updateSensorSettings(uuid, settings) {
        try {
          console.log('=== 센서 설정값 업데이트 ===');
          console.log('장치 UUID:', uuid);
          console.log('설정값:', settings);
          
          // 설정온도 (p01) 처리
          if (settings.p01 !== undefined) {
            var setTemp = parseFloat(settings.p01) / 10; // 160 → 16.0
            console.log('설정온도 파싱:', settings.p01, '→', setTemp + '°C');
            
            // 설정온도 UI 업데이트
            var setTempElement = $('#setTmp' + uuid);
            if (setTempElement.length > 0) {
              setTempElement.html('<font size="10px">' + setTemp + '°C</font>');
              console.log('설정온도 UI 업데이트 완료:', setTemp + '°C');
            } else {
              console.warn('설정온도 표시 요소를 찾을 수 없음:', 'setTmp' + uuid);
            }
          }
          
          // 다른 설정값들도 필요시 추가 처리
          if (settings.p02 !== undefined) {
            var hysteresis = parseFloat(settings.p02) / 10; // 10 → 1.0
            console.log('히스테리시스 편차:', hysteresis + '°C');
          }
          
          if (settings.p16 !== undefined) {
            var deviceType = settings.p16;
            console.log('장치종류:', deviceType === '1' ? 'Heater' : 'Cooler');
            
            // 장치종류 UI 표시 (기존 요소에 표시)
            var deviceTypeElement = $('#deviceType' + uuid);
            if (deviceTypeElement.length > 0) {
              var deviceTypeText = deviceType === '1' ? '(Heater)' : '(Cooler)';
              deviceTypeElement.text(deviceTypeText);
              console.log('장치종류 UI 업데이트 완료:', deviceTypeText);
            } else {
              console.warn('장치종류 표시 요소를 찾을 수 없음:', 'deviceType' + uuid);
            }
            
            // 장치종류에 따른 제상 라벨 변경
            var defrostLabel = $('#defrostLabel' + uuid);
            if (defrostLabel.length > 0) {
              if (deviceType === '1') {
                defrostLabel.text('가열');
              } else {
                defrostLabel.text('제상');
              }
            }
            
            // 장치종류 전역 변수에 저장 (다른 함수에서 사용)
            window['deviceType_' + uuid] = deviceType;
          }
          
          console.log('=== 센서 설정값 업데이트 완료 ===');
        } catch (e) {
          console.error('센서 설정값 업데이트 오류:', e);
        }
      }
      
      // Digital Input 상태 업데이트
      function updateDinStatus(uuid, value) {
        try {
          // value가 1이면 이상 상태, 0이면 정상 상태
          if (value === "1" || value === 1) {
            // 이상 상태: 빨간색
            updateError(uuid, 'red');
            // DIN 이상 상태 플래그 설정
            window['deviceDinErrorStates_' + uuid] = true;
          } else {
            // 정상 상태: 회색
            updateError(uuid, 'gray');
            // DIN 이상 상태 플래그 해제
            window['deviceDinErrorStates_' + uuid] = false;
          }
        } catch (e) {
          console.error('DIN 상태 업데이트 오류:', e);
        }
      }
      
      // Output 상태 업데이트
      function updateOutputStatus(uuid, type, ch, value) {
        try {
          // type에 따른 상태 업데이트
          switch (type) {
            case "1": // COMP (콤프)
              updateComp(uuid, value === "1" ? 'red' : 'gray');
              break;
            case "2": // DEF (제상)
              updateDefr(uuid, value === "1" ? 'red' : 'gray');
              break;
            case "3": // FAN
              updateFan(uuid, value === "1" ? 'red' : 'gray');
              break;
            case "4": // DOUT (Digital Output)
              // 필요시 추가 처리
              break;
            case "5": // ROUT (Relay Output)
              // 필요시 추가 처리
              break;
            case "6": // AOUT (Analog Output)
              // 필요시 추가 처리
              break;
          }
        } catch (e) {
          console.error('Output 상태 업데이트 오류:', e);
        }
      }
      
      // Analog Input 상태 업데이트 (현재온도)
      function updateAinStatus(uuid, value) {
        try {
          // 온도값이 "Error"인 경우
          if (value === "Error" || value === "error") {
            // 온도 표시를 "Error"로 설정
            $('#sensorVal' + uuid).html('<font size="50px">Error</font>');
            // 에러 상태 체크
            chkError(uuid);
          } else {
            // 정상 온도값 표시
            $('#sensorVal' + uuid).html('<font size="50px">' + value + '°C</font>');
            // 에러 상태 해제
            clearError(uuid);
          }
        } catch (e) {
          console.error('AIN 상태 업데이트 오류:', e);
        }
      }
      
      // 에러 상태 해제
      function clearError(uuid) {
        try {
          // 에러 카운터 초기화
          window['deviceErrorCounters_' + uuid] = 0;
          // 에러 상태 해제
          window['deviceErrorStates_' + uuid] = false;
          // 마지막 데이터 시간 업데이트
          window['deviceLastDataTime_' + uuid] = Date.now();
        } catch (e) {
          console.error('에러 상태 해제 오류:', e);
        }
      }
      
      // 상태별 업데이트 함수들 (설정페이지와 동일한 방식)
      
      // 운전 상태 업데이트
      function updateStatus(uuid, status) {
        try {
          var elementId = 'status' + uuid;
          var element = $('#' + elementId);
          if (element.length > 0) {
            // CSS 클래스 변경 (설정페이지와 동일)
            element.removeClass('green gray red').addClass('status-indicator ' + status);
            
            // 부트스트랩 아이콘 유지하면서 상태에 따른 아이콘 변경
            var iconClass = status === 'green' ? 'bi-play-circle-fill' : 'bi-pause-circle-fill';
            element.find('i').removeClass().addClass('bi ' + iconClass);
          }
        } catch (e) {
          console.error('Status update error:', e);
        }
      }

      // 콤프 상태 업데이트
      function updateComp(uuid, status) {
        try {
          var elementId = 'comp' + uuid;
          var element = $('#' + elementId);
          if (element.length > 0) {
            element.removeClass('green gray red').addClass('status-indicator ' + status);
            // 부트스트랩 아이콘 유지
            element.find('i').removeClass().addClass('bi bi-gear-fill');
          }
        } catch (e) {
          console.error('Comp update error:', e);
        }
      }

      // 제상 상태 업데이트
      function updateDefr(uuid, status) {
        try {
          var elementId = 'defr' + uuid;
          var element = $('#' + elementId);
          if (element.length > 0) {
            element.removeClass('green gray red').addClass('status-indicator ' + status);
            // 장치종류에 따라 아이콘 결정 (설정페이지와 동일)
            var deviceType = window['deviceType_' + uuid] || '0';
            var iconClass = deviceType === '1' ? 'bi-thermometer-half' : 'bi-snow';
            element.find('i').removeClass().addClass('bi ' + iconClass);
          }
        } catch (e) {
          console.error('Defr update error:', e);
        }
      }

      // FAN 상태 업데이트
      function updateFan(uuid, status) {
        try {
          var elementId = 'fan' + uuid;
          var element = $('#' + elementId);
          if (element.length > 0) {
            element.removeClass('green gray red').addClass('status-indicator ' + status);
            // 부트스트랩 아이콘 유지
            element.find('i').removeClass().addClass('bi bi-fan');
          }
        } catch (e) {
          console.error('Fan update error:', e);
        }
      }

      // 이상 상태 업데이트
      function updateError(uuid, status) {
        try {
          var elementId = 'error' + uuid;
          var element = $('#' + elementId);
          if (element.length > 0) {
            element.removeClass('green gray red').addClass('status-indicator ' + status);
            // 부트스트랩 아이콘 유지
            element.find('i').removeClass().addClass('bi bi-exclamation-triangle-fill');
          }
        } catch (e) {
          console.error('Error update error:', e);
        }
      }
    </script>
      </body>
  </html>