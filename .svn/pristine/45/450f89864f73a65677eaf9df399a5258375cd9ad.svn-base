package com.andrew.hnt.api.mqtt;

import java.io.IOException;
import java.util.*;

import com.andrew.hnt.api.config.DbConfig;
import com.andrew.hnt.api.mapper.LoginMapper;
import com.andrew.hnt.api.mapper.MqttMapper;
import com.andrew.hnt.api.model.LoginVO;
import com.andrew.hnt.api.model.SensorVO;
import com.andrew.hnt.api.model.UserInfo;
import com.andrew.hnt.api.service.AdminService;
import com.andrew.hnt.api.service.LoginService;
import com.andrew.hnt.api.service.impl.LoginServiceImpl;
import com.andrew.hnt.api.service.impl.MqttServiceImpl;
import com.fasterxml.jackson.databind.ObjectMapper;
import okhttp3.*;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import com.andrew.hnt.api.mqtt.common.MQTT;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.andrew.hnt.api.service.DeviceRegistrationService;
import javax.annotation.PreDestroy;

@Component
public class MqttApplicationRunner implements ApplicationRunner {

	private Logger logger = LoggerFactory.getLogger(this.getClass());

	@Autowired
	private MqttMapper mqttMapper;

	@Autowired
	private LoginService loginService;

	@Autowired
	private AdminService adminService;
	
	@Autowired
	private MqttServiceImpl mqttService;

	@Autowired
	private DeviceRegistrationService deviceRegistrationService;

	private String apiKey = "AAAAoUCvVY0:APA91bFhv_a-RRU0OOJPmGk4MBri_Aqu0MW4r1CDfar4GrhQf3H9XPTWRhoul86dfhLTomTn-WsTrKJ-qPAakoap9vMl7JHmrj8WniVnTQE3y5mhxKFDPp09bAmjaAuDx8qUXH1qhO05";
	private String senderId = "692574967181";

	private String sensorVal = "";
	private String sensorUuid = "";

	// 장치별 마지막 저장 시간과 값을 추적 (1분마다 저장)
	private Map<String, Long> lastSaveTime = new HashMap<>();
	private Map<String, String> lastSensorValue = new HashMap<>();
	private static final long SAVE_INTERVAL = 60000; // 1분 (60초 * 1000ms)

    private static volatile boolean started = false;
    
    // 리소스 관리를 위한 변수들
    private Timer timer;
    private MQTT mqttClient;
    private Thread mqttThread;
    private volatile boolean running = false;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        if (started) {
            logger.warn("MqttApplicationRunner 이미 시작됨 - 중복 실행 방지");
            return;
        }
        started = true;
        running = true;
        
		System.out.println("MQTT Application Runner started");
		String MqttServer1 = "tcp://iot.hntsolution.co.kr:1883";
		String client_id = "";
		String userName = "hnt1";
		String password = "abcde";
		String topic = "#";
		String msg = "";
		String readMsg = "";
		String readTopic = "";

		client_id = UUID.randomUUID().toString();
		
		mqttClient = new MQTT(MqttServer1, client_id, userName, password);
		mqttClient.init(topic, "Y");

		// Timer 대신 Thread 사용 (더 안전한 관리)
		mqttThread = new Thread(() -> {
			while (running) {
				try {
					Map<String, Object> resultMap = new HashMap<String, Object>();
					String currentMsg = "";
					String currentTopic = "";
					currentMsg = mqttClient.getMsg();
					currentTopic = mqttClient.getRcvTopic();

					if(null != currentTopic && !"".equals(currentTopic) && 0 < currentTopic.length()) {
						// 기존 로직 유지
						processMqttMessage(currentTopic, currentMsg);
					}
					
					// 1초 대기
					Thread.sleep(1000);
				} catch (Exception e) {
					logger.error("MQTT 메시지 처리 중 오류 발생", e);
					try {
						Thread.sleep(5000); // 오류 시 5초 대기
					} catch (InterruptedException ie) {
						Thread.currentThread().interrupt();
						break;
					}
				}
			}
		});
		
		// Daemon 스레드로 설정하여 메인 애플리케이션 종료 시 자동 정리
		mqttThread.setDaemon(true);
		mqttThread.setName("MQTT-Thread");
		mqttThread.start();
		
		logger.warn("MQTT Application Runner 시작 완료 - Daemon 스레드로 실행");
	}
	
	// MQTT 메시지 처리 로직을 별도 메서드로 분리
	private void processMqttMessage(String topic, String readMsg) {
		try {
			// register 토픽 처리
			if(topic.contains("register")) {
				// 토픽에서 사용자 ID 추출
				String[] topicArr = topic.split("/");
				
				if(null != topicArr && topicArr.length >= 2) {
					String userId = topicArr[1];
					String mac = ""; // JSON에서 추출할 예정
					
					// kimtest 사용자만 상세 로깅
					boolean isKimtest = "kimtest".equals(userId);
					if(isKimtest) {
						logger.info("=== register 토픽 감지: {} ===", topic);
					}
					
					// JSON 메시지에서 MAC 주소 추출 (최적화)
					if(isValidJson(readMsg)) {
						try {
							ObjectMapper mapper = new ObjectMapper();
							Map<String, Object> jsonData = mapper.readValue(readMsg, Map.class);
							
							// MAC 주소 필드 우선순위로 확인
							if(jsonData.containsKey("mac")) {
								mac = String.valueOf(jsonData.get("mac"));
							} else if(jsonData.containsKey("uuid")) {
								mac = String.valueOf(jsonData.get("uuid"));
							} else if(jsonData.containsKey("deviceId")) {
								mac = String.valueOf(jsonData.get("deviceId"));
							}
							
							if(!"".equals(mac)) {
								// 즉시 응답 전송
								String responseMessage = "REG&value=1";
								String responseTopic = String.format("HBEE/%s/TC/%s/SER", userId, mac);
								
								mqttClient.publish(responseMessage, 0, responseTopic);
								if(isKimtest) {
									logger.info("즉시 응답 전송 완료: {}", responseTopic);
								}
								
								// DeviceRegistrationService 호출하여 실제 장치 등록 진행
								try {
									boolean registrationSuccess = deviceRegistrationService.processDeviceRegistration(userId, "TC", mac);
									if(isKimtest) {
										if(registrationSuccess) {
											logger.info("장치 등록 완료: userId={}, mac={}", userId, mac);
										} else {
											logger.error("장치 등록 실패: userId={}, mac={}", userId, mac);
										}
									}
								} catch (Exception e) {
									if(isKimtest) {
										logger.error("DeviceRegistrationService 호출 중 오류: userId={}, mac={}", userId, mac, e);
									} else {
										logger.error("DeviceRegistrationService 호출 중 오류: userId={}, mac={}", userId, mac);
									}
								}
							}
						} catch (Exception e) {
							if(isKimtest) {
								logger.error("JSON 파싱 실패: {}", e.getMessage());
							}
						}
					}
				}
				
				// MqttServiceImpl.receiveData()로 전달
				mqttService.receiveData(topic);
				return; // register 토픽은 센서 데이터로 처리하지 않음
			}
			
			ObjectMapper mapper = new ObjectMapper();
			Map<String, Object> value = new HashMap<String, Object>();

			SensorVO sensorVO = new SensorVO();
			String name = "";

			sensorVO.setTopic(topic);
			sensorVO.setRawData(readMsg);

			if(isValidJson(readMsg)) {
				value = mapper.readValue(readMsg, Map.class);
			}
			String[] topicArr = null;
			if(topic.contains("/")) {
				topicArr = topic.split("/");
			}

			if(null != topicArr && topicArr.length >= 4) {
				sensorVO.setUserId(topicArr[1]);
				sensorVO.setSensorId(topicArr[1]);
				sensorVO.setSensorType(topicArr[2]);
				sensorVO.setUuid(topicArr[3]);
			} else if(null != topicArr && topicArr.length >= 3) {
				// 3개 요소만 있는 경우 (예: HBEE/kimtest/TC)
				sensorVO.setUserId(topicArr[1]);
				sensorVO.setSensorId(topicArr[1]);
				sensorVO.setSensorType(topicArr[2]);
				// UUID는 설정하지 않음
			}
			

			if(null != value && 0 < value.size() && value.containsKey("name")) {
				name = String.valueOf(value.get("name"));
				if("ain".equals(name)) {
					sensorVO.setSensorValue(String.valueOf(value.get("value")));
				}
			}

			sensorVO.setInstId("hnt");
			sensorVO.setMdfId("hnt");

			if(null != sensorVO.getUserId() && !"".equals(sensorVO.getUserId()) && 0 < sensorVO.getUserId().length() && null != sensorVO.getSensorValue() && !"".equals(sensorVO.getSensorValue())) {
				if(!sensorVal.equals(sensorVO.getSensorValue()) || !sensorUuid.equals(sensorVO.getUuid())) {
					insertSensorDataWithTransaction(sensorVO);
					sensorVal = sensorVO.getSensorValue();
					sensorUuid = sensorVO.getUuid();
				}
			}
		} catch(Exception e) {
			logger.error("MQTT 메시지 처리 중 오류 발생: {}", e.getMessage());
		}
	}

	public void sendNoti(Map<String, Object> noti) {
		if(null != noti && 0 < noti.size()) {
			OkHttpClient client = new OkHttpClient.Builder().build();

			String inTemp = "";
			String curTemp = "";
			String gu = "";
			String warnText = "";
			String inType = "";
			String sensorName = "";

			gu = String.valueOf(noti.get("gu"));
			inTemp = String.valueOf(noti.get("inTemp"));
			curTemp = String.valueOf(noti.get("curTemp"));
			inType = String.valueOf(noti.get("inType"));
			sensorName = String.valueOf(noti.get("sensor_uuid"));

			if(null != gu && !"".equals(gu) && 0 < gu.length()) {
				if("ain".equals(gu)) {
					if(null != inType && !"".equals(inType) && 0 < inType.length()) {
						if("high".equals(inType)) {
							warnText = "온도 높음(설정온도 : " + curTemp + "°C, 현재온도 : " + inTemp + "°C)";
						} else if("low".equals(inType)) {
							warnText = "온도 낮음(설정온도 : " + curTemp + "°C, 현재온도 : " + inTemp + "°C)";
						}
					}
				} else if("din".equals(gu)) {
					warnText = "DI알람(에러, 현재온도 : " + inTemp +")";
				}
			}

			okhttp3.RequestBody body = new FormBody.Builder()
					.add("to", String.valueOf(noti.get("token")))
					.add("project_id", senderId)
					.add("notification", "")
					.add("data", sensorName + "장치 이상 발생 : " + warnText)
					.build();

			Request request = new Request.Builder()
					.url("https://fcm.googleapis.com/fcm/send")
					.addHeader("Authorization", "key=" + apiKey)
					.post(body)
					.build();

			client.newCall(request).enqueue(new Callback() {
				@Override
				public void onFailure(@NotNull Call call, @NotNull IOException e) {
					logger.error("Error");
				}

				@Override
				public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
					if (response.isSuccessful()) {
						logger.info("Success : " + response.code() + "/" + response.body().string());
					} else {
						logger.info("Fail : " + response.code() + "/" + response.body().string());
					}
				}
			});
		}
	}

	public boolean isValidJson(String str) {
		boolean result = false;

		ObjectMapper mapper = new ObjectMapper();

		try {
			mapper.readTree(str);
			result = true;
		} catch(Exception e) {
			result = false;
		}

		return result;
	}

	void sleep(int time) {
		try {
			Thread.sleep(time);
		} catch(InterruptedException ite) {
			ite.printStackTrace();
		}
	}
	
	/**
	 * 트랜잭션을 사용하여 센서 데이터 저장 (임시 비활성화)
	 */
	@Transactional
	public void insertSensorDataWithTransaction(SensorVO sensorVO) {
		try {
			mqttMapper.insertSensorData(sensorVO);
			logger.debug("센서 데이터 저장 성공 - sensorId: {}, uuid: {}, value: {}", 
					   sensorVO.getSensorId(), sensorVO.getUuid(), sensorVO.getSensorValue());
		} catch (Exception e) {
			logger.error("센서 데이터 저장 실패 - sensorId: {}, uuid: {}, error: {}", 
					   sensorVO.getSensorId(), sensorVO.getUuid(), e.getMessage(), e);
			throw e; // 트랜잭션 롤백을 위해 예외 재발생
		}
	}

	// 애플리케이션 종료 시 리소스 정리
	@PreDestroy
	public void cleanup() {
		logger.warn("MQTT Application Runner 리소스 정리 시작");
		
		// 실행 중지 플래그 설정
		running = false;
		
		// MQTT 스레드 정리
		if (mqttThread != null && mqttThread.isAlive()) {
			mqttThread.interrupt();
			try {
				mqttThread.join(5000); // 5초 대기
				if (mqttThread.isAlive()) {
					logger.warn("MQTT 스레드 강제 종료");
				}
			} catch (InterruptedException e) {
				logger.warn("MQTT 스레드 정리 중 인터럽트 발생");
				Thread.currentThread().interrupt();
			}
		}
		
		// MQTT 클라이언트 정리
		if (mqttClient != null) {
			try {
				// MQTT 연결 종료 로직이 있다면 호출
				logger.warn("MQTT 클라이언트 정리 완료");
			} catch (Exception e) {
				logger.error("MQTT 클라이언트 정리 중 오류 발생", e);
			}
		}
		
		// Timer 정리 (혹시 남아있다면)
		if (timer != null) {
			timer.cancel();
			timer.purge();
			logger.warn("Timer 정리 완료");
		}
		
		logger.warn("MQTT Application Runner 리소스 정리 완료");
	}
}