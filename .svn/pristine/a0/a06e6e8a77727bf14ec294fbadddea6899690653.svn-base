// Called after form input is processed
function startConnect() {
    // random client ID 생성
    _clientId_ = window.localStorage.getItem("clientId");
    //console.log("clientId : " + _clientId_);

    if(_clientId_  != "" && _clientId_ != null) {
        clientID = _clientId_;
    } else {
        clientID = "clientID-" + parseInt(Math.random() * 100);
        window.localStorage.setItem("clientId", clientID);
    }

    // broker IP , broker websocket port
    host = "iot.hntsolution.co.kr";
    port = "9001";

    console.log("Connecting to: "+host+"  on port: "+port+" / clinet value: "+clientID);

    // connection
    client = new Paho.MQTT.Client(host, Number(port), clientID);

    // callback
    client.onConnectionLost = onConnectionLost;

    if(client.isConnected()) {
        //console.log("already connected");
    } else {
        // Connect the client, if successful, call onConnect function
        //console.log("connect needed");
        client.connect({
            onSuccess: onConnect,
            onFailure: onFailure,
            userName: 'hnt1',
            password: 'abcde',
            cleanSession: true,
            keepAliveInterval: 60,  // 60초로 변경
            mqttVersion: 4,
            timeout: 30,  // 30초 타임아웃 추가
            useSSL: false,  // SSL 사용 안함
            reconnect: true,  // 자동 재연결 활성화
            maxReconnectAttempts: 10  // 최대 재연결 시도 횟수
        });
    }
}

function onConnect() {
    topic = "#"; //MQTT 토픽명 (#은 모든 토픽 허용)

    // Print output
    console.log("MQTT 연결 성공: " + topic);
    client.onMessageArrived = onMessageArrived;
    
    // 연결 상태 업데이트
    if (typeof updateMqttStatus === 'function') {
        updateMqttStatus('connected', '실시간 데이터 수신 중');
    }
    
    // 연결 성공 후 구독
    try {
        client.subscribe(topic, {
            onSuccess: function() {
                console.log("MQTT 구독 성공: " + topic);
            },
            onFailure: function(err) {
                console.log("MQTT 구독 실패: " + err.errorMessage);
                if (typeof updateMqttStatus === 'function') {
                    updateMqttStatus('error', '구독 실패: ' + err.errorMessage);
                }
            }
        });
    } catch(e) {
        console.log("MQTT 구독 중 오류: " + e.message);
        if (typeof updateMqttStatus === 'function') {
            updateMqttStatus('error', '구독 오류: ' + e.message);
        }
    }
}

function onFailure(error) {
    console.log("MQTT 연결 실패: " + error.errorMessage);
    if(error.errorCode) {
        console.log("MQTT 에러 코드: " + error.errorCode);
    }
    
    // 연결 실패 상태 업데이트
    if (typeof updateMqttStatus === 'function') {
        updateMqttStatus('error', '연결 실패: ' + error.errorMessage);
    }
    
    setTimeout(function() { startConnect(); }, 5000); // 5초 후 재연결
}

// connection error
function onConnectionLost(responseObject) {
    console.log('Connection lost: ' + responseObject.errorMessage);
    if(responseObject.errorCode) {
        console.log("연결 끊김 에러 코드: " + responseObject.errorCode);
    }
    
    // 연결 끊김 상태 업데이트
    if (typeof updateMqttStatus === 'function') {
        updateMqttStatus('disconnected', '연결이 끊어졌습니다. 재연결 시도 중...');
    }
    
    setTimeout(function() { startConnect(); }, 10000); // 10초 후 재연결
}

// subsribe output
function onMessageArrived(message) {
    //console.log(message.destinationName);
    //console.log(message.payloadString);
    rcvMsg(message.destinationName, message.payloadString);
}

// send a message (publish)
function publish (element) {
    var topic = $(element).attr("id"); //버튼의 id를 topic으로 설정

    if(element.checked == true){
        var message = "ON";
    } else {
        var message = "OFF";
    }

    message = new Paho.MQTT.Message(message);
    message.destinationName = topic;
    message.qos = 2;

    client.send(message);
}


// disconnection
function startDisconnect() {
    client.disconnect();
    //document.getElementById("messages").innerHTML += '<span>Disconnected</span><br/>';
    //alert("disconnected!!!");
}

function validateJson(str) {
    try {
        JSON.parse(str);
        return true;
    } catch(e) {
        return false;
    }
}
